<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>unirec: unirec.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">unirec
   &#160;<span id="projectnumber">2.2.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">unirec.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Definition of UniRec structures and functions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;inttypes.h&gt;</code><br />
<code>#include &lt;time.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;regex.h&gt;</code><br />
<code>#include &quot;unirec.h&quot;</code><br />
<code>#include &lt;libtrap/trap.h&gt;</code><br />
<code>#include &quot;ur_values.c&quot;</code><br />
<code>#include &quot;inline.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gabf382d0ceec2ca2d62cb94ecf000ecd4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabf382d0ceec2ca2d62cb94ecf000ecd4"></a>
INLINE_IMPL int&#160;</td><td class="memItemRight" valign="bottom"><b>ip_is4</b> (const <a class="el" href="unionip__addr__u.html">ip_addr_t</a> *addr)</td></tr>
<tr class="separator:gabf382d0ceec2ca2d62cb94ecf000ecd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaa8f3d94315e53ebf8c43c7dde8f6cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeaa8f3d94315e53ebf8c43c7dde8f6cb"></a>
INLINE_IMPL int&#160;</td><td class="memItemRight" valign="bottom"><b>ip_is6</b> (const <a class="el" href="unionip__addr__u.html">ip_addr_t</a> *addr)</td></tr>
<tr class="separator:gaeaa8f3d94315e53ebf8c43c7dde8f6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6ab3a77cab8533289729b25c9438689"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae6ab3a77cab8533289729b25c9438689"></a>
INLINE_IMPL uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>ip_get_v4_as_int</b> (<a class="el" href="unionip__addr__u.html">ip_addr_t</a> *addr)</td></tr>
<tr class="separator:gae6ab3a77cab8533289729b25c9438689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2c790297e16730292696c44306dd1a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac2c790297e16730292696c44306dd1a6"></a>
INLINE_IMPL char *&#160;</td><td class="memItemRight" valign="bottom"><b>ip_get_v4_as_bytes</b> (const <a class="el" href="unionip__addr__u.html">ip_addr_t</a> *addr)</td></tr>
<tr class="separator:gac2c790297e16730292696c44306dd1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad57ac58e8823c5197445e9035843a417"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad57ac58e8823c5197445e9035843a417"></a>
INLINE_IMPL <a class="el" href="unionip__addr__u.html">ip_addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ip_from_int</b> (uint32_t i)</td></tr>
<tr class="separator:gad57ac58e8823c5197445e9035843a417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c694d465f540e700d91a655f6d47ebd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2c694d465f540e700d91a655f6d47ebd"></a>
INLINE_IMPL <a class="el" href="unionip__addr__u.html">ip_addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ip_from_4_bytes_be</b> (char b[4])</td></tr>
<tr class="separator:ga2c694d465f540e700d91a655f6d47ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34b4da3670a99958f7038c90da2b7152"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga34b4da3670a99958f7038c90da2b7152"></a>
INLINE_IMPL <a class="el" href="unionip__addr__u.html">ip_addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ip_from_4_bytes_le</b> (char b[4])</td></tr>
<tr class="separator:ga34b4da3670a99958f7038c90da2b7152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61daf049c5a24cd2a331d916694a4fef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga61daf049c5a24cd2a331d916694a4fef"></a>
INLINE_IMPL <a class="el" href="unionip__addr__u.html">ip_addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ip_from_16_bytes_be</b> (char b[16])</td></tr>
<tr class="separator:ga61daf049c5a24cd2a331d916694a4fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35a767afac198cabbbb7cf5ea70c9e33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga35a767afac198cabbbb7cf5ea70c9e33"></a>
INLINE_IMPL <a class="el" href="unionip__addr__u.html">ip_addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ip_from_16_bytes_le</b> (char b[16])</td></tr>
<tr class="separator:ga35a767afac198cabbbb7cf5ea70c9e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b852d36a8e8b8932058fba40570a24a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6b852d36a8e8b8932058fba40570a24a"></a>
INLINE_IMPL int&#160;</td><td class="memItemRight" valign="bottom"><b>ip_cmp</b> (const <a class="el" href="unionip__addr__u.html">ip_addr_t</a> *addr1, const <a class="el" href="unionip__addr__u.html">ip_addr_t</a> *addr2)</td></tr>
<tr class="separator:ga6b852d36a8e8b8932058fba40570a24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae01409ca18c16d2b28292ff94802b51b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae01409ca18c16d2b28292ff94802b51b"></a>
INLINE_IMPL int&#160;</td><td class="memItemRight" valign="bottom"><b>ip_from_str</b> (const char *str, <a class="el" href="unionip__addr__u.html">ip_addr_t</a> *addr)</td></tr>
<tr class="separator:gae01409ca18c16d2b28292ff94802b51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4aa063dc904a602c2ee1f46bf50315e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4aa063dc904a602c2ee1f46bf50315e7"></a>
INLINE_IMPL void&#160;</td><td class="memItemRight" valign="bottom"><b>ip_to_str</b> (const <a class="el" href="unionip__addr__u.html">ip_addr_t</a> *addr, char *str)</td></tr>
<tr class="separator:ga4aa063dc904a602c2ee1f46bf50315e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238d68dc4d1dc5b0369e907b0e2d9711"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#a238d68dc4d1dc5b0369e907b0e2d9711">ur_init</a> (<a class="el" href="structur__static__field__specs__t.html">ur_static_field_specs_t</a> field_specs_static)</td></tr>
<tr class="memdesc:a238d68dc4d1dc5b0369e907b0e2d9711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize UniRec structures Initialize UniRec structures. Function is called during defining first own field.  <a href="#a238d68dc4d1dc5b0369e907b0e2d9711">More...</a><br /></td></tr>
<tr class="separator:a238d68dc4d1dc5b0369e907b0e2d9711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbfcce0fe6729ceb692d09541336c33"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#abfbfcce0fe6729ceb692d09541336c33">ur_template_string_delimiter</a> (const <a class="el" href="structur__template__t.html">ur_template_t</a> *tmplt, int delimiter)</td></tr>
<tr class="memdesc:abfbfcce0fe6729ceb692d09541336c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive data from interface with given context Receive data with specified template from libtrap interface with specified context. If the receiving template is subset of sending template, it will define new fields and expand receiving template.  <a href="#abfbfcce0fe6729ceb692d09541336c33">More...</a><br /></td></tr>
<tr class="separator:abfbfcce0fe6729ceb692d09541336c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98890a8d9702c533d4d1d1e7921f74e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#a98890a8d9702c533d4d1d1e7921f74e6">ur_get_empty_id</a> ()</td></tr>
<tr class="memdesc:a98890a8d9702c533d4d1d1e7921f74e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return first empty id for new UniRec field Return first empty id for new UniRec field. If there is no space in the UniRec structures, it will increase space in the existing structures.  <a href="#a98890a8d9702c533d4d1d1e7921f74e6">More...</a><br /></td></tr>
<tr class="separator:a98890a8d9702c533d4d1d1e7921f74e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae511d9e52485818f2513fe5f2e1d564c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae511d9e52485818f2513fe5f2e1d564c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ur_get_field_type_from_str</b> (const char *type)</td></tr>
<tr class="separator:ae511d9e52485818f2513fe5f2e1d564c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dad0e5a16c5828870041e64270e1943"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1dad0e5a16c5828870041e64270e1943"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>ur_get_type_and_name_from_string</b> (const char *source, char **name, char **type, int *length_name, int *length_type)</td></tr>
<tr class="separator:a1dad0e5a16c5828870041e64270e1943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d468a710c302abfc212784c99ef889"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#a31d468a710c302abfc212784c99ef889">ur_ifc_data_fmt_to_field_names</a> (const char *ifc_data_fmt)</td></tr>
<tr class="memdesc:a31d468a710c302abfc212784c99ef889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses field names from data format Function parses field names from data format and returns pointer to new allocated string. Example: "type1 name1,type2 name2" =&gt; "name1,name2" New string has to be freed by user.  <a href="#a31d468a710c302abfc212784c99ef889">More...</a><br /></td></tr>
<tr class="separator:a31d468a710c302abfc212784c99ef889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b52aaae2bd3aa7d38b119a95a275e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structur__template__t.html">ur_template_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#ac2b52aaae2bd3aa7d38b119a95a275e9">ur_expand_template</a> (const char *ifc_data_fmt, <a class="el" href="structur__template__t.html">ur_template_t</a> *tmplt)</td></tr>
<tr class="memdesc:ac2b52aaae2bd3aa7d38b119a95a275e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand UniRec template Expand existing UniRec template by a string containing types and names of its fields separated by commas. Example ifc_data_fmt: "uint32 FOO,uint8 BAR,float FOO2" Order of fields is not important (templates with the same set of fields are equivalent). In case of success the given template will be destroyed and new template will be returned.  <a href="#ac2b52aaae2bd3aa7d38b119a95a275e9">More...</a><br /></td></tr>
<tr class="separator:ac2b52aaae2bd3aa7d38b119a95a275e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5a6441796f8df8c63645298170f8f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#adc5a6441796f8df8c63645298170f8f4">ur_define_set_of_fields</a> (const char *ifc_data_fmt)</td></tr>
<tr class="memdesc:adc5a6441796f8df8c63645298170f8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define set of new UniRec fields Define new UniRec fields at run-time. It adds new fields into existing structures. If the field already exists and type is equal nothing will happen. If the type is not equal an error will be returned. Example ifc_data_fmt: "uint32 FOO,uint8 BAR,float FOO2".  <a href="#adc5a6441796f8df8c63645298170f8f4">More...</a><br /></td></tr>
<tr class="separator:adc5a6441796f8df8c63645298170f8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b090390e3e2728d2d59168eb532633a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structur__template__t.html">ur_template_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#a4b090390e3e2728d2d59168eb532633a">ur_define_fields_and_update_template</a> (const char *ifc_data_fmt, <a class="el" href="structur__template__t.html">ur_template_t</a> *tmplt)</td></tr>
<tr class="memdesc:a4b090390e3e2728d2d59168eb532633a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined new fields and expand an UniRec template Define new fields (function ur_define_set_of_fields) and create new UniRec template (function ur_create_template_from_ifc_spec). The string describing fields contain types and names of fields separated by commas. Example ifc_data_fmt: "uint32 FOO,uint8 BAR,float FOO2" Order of fields is not important (templates with the same set of fields are equivalent). In case of success the given template will be destroyed and new template will be returned.  <a href="#a4b090390e3e2728d2d59168eb532633a">More...</a><br /></td></tr>
<tr class="separator:a4b090390e3e2728d2d59168eb532633a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a76a48d18a09ee2f32ed638bbcbcf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structur__template__t.html">ur_template_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#ae1a76a48d18a09ee2f32ed638bbcbcf7">ur_create_template_from_ifc_spec</a> (const char *ifc_data_fmt)</td></tr>
<tr class="memdesc:ae1a76a48d18a09ee2f32ed638bbcbcf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create UniRec template from data format string. Creates new UniRec template (function ur_create_template_from_ifc_spec). The string describing fields contain types and names of fields separated by commas. Example ifc_data_fmt: "uint32 FOO,uint8 BAR,float FOO2" Order of fields is not important (templates with the same set of fields are equivalent)..  <a href="#ae1a76a48d18a09ee2f32ed638bbcbcf7">More...</a><br /></td></tr>
<tr class="separator:ae1a76a48d18a09ee2f32ed638bbcbcf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9296343268e2117e4f53705c0cdf3a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#ae9296343268e2117e4f53705c0cdf3a5">ur_define_field</a> (const char *name, ur_field_type_t type)</td></tr>
<tr class="memdesc:ae9296343268e2117e4f53705c0cdf3a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define new UniRec field Define new UniRec field at run-time. It adds new field into existing structures. If the field already exists (name and type are equal) it only returns its ID.  <a href="#ae9296343268e2117e4f53705c0cdf3a5">More...</a><br /></td></tr>
<tr class="separator:ae9296343268e2117e4f53705c0cdf3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8940c1aab20e50ab84da99715322fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#a0d8940c1aab20e50ab84da99715322fc">ur_undefine_field_by_id</a> (ur_field_id_t field_id)</td></tr>
<tr class="memdesc:a0d8940c1aab20e50ab84da99715322fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undefine UniRec field by its id Undefine UniRec field created at run-time. It erases given field from UniRec structures and the field ID can be used for another field. By undefining field, all templates which were using the undefined field, has to be recreated.  <a href="#a0d8940c1aab20e50ab84da99715322fc">More...</a><br /></td></tr>
<tr class="separator:a0d8940c1aab20e50ab84da99715322fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7d40d098716943f035185d26aeff29"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#a3b7d40d098716943f035185d26aeff29">ur_undefine_field</a> (const char *name)</td></tr>
<tr class="memdesc:a3b7d40d098716943f035185d26aeff29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undefine UniRec field by its name Undefine UniRec field created at run-time. It erases given field from UniRec structures and the field ID can be used for another field. By undefining field, all templates which were using the undefined field, has to be recreated.  <a href="#a3b7d40d098716943f035185d26aeff29">More...</a><br /></td></tr>
<tr class="separator:a3b7d40d098716943f035185d26aeff29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77bb16e4585117517a5d7aabebcb8a0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77bb16e4585117517a5d7aabebcb8a0a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#a77bb16e4585117517a5d7aabebcb8a0a">ur_finalize</a> ()</td></tr>
<tr class="memdesc:a77bb16e4585117517a5d7aabebcb8a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate UniRec structures Deallocate UniRec structures at the end of a program. This function SHOULD be called after all UniRec functions and macros invocations, typically during a cleanup phase before the program's end. This function has to be called if some fields are defined during run-time, otherwise this function is needless. <br /></td></tr>
<tr class="separator:a77bb16e4585117517a5d7aabebcb8a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04af6d1916490e641f7640e440a8e7c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#ae04af6d1916490e641f7640e440a8e7c">ur_get_id_by_name</a> (const char *name)</td></tr>
<tr class="memdesc:ae04af6d1916490e641f7640e440a8e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ID of a field by its name Get ID of a field by its name.  <a href="#ae04af6d1916490e641f7640e440a8e7c">More...</a><br /></td></tr>
<tr class="separator:ae04af6d1916490e641f7640e440a8e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af893df4c0a8d17cae3f8999e9bcce312"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#af893df4c0a8d17cae3f8999e9bcce312">compare_fields</a> (const void *field1, const void *field2)</td></tr>
<tr class="memdesc:af893df4c0a8d17cae3f8999e9bcce312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare fields Compare two fields. This function is for sorting the fields in the right order. First by sizes (larger first) and then by names.  <a href="#af893df4c0a8d17cae3f8999e9bcce312">More...</a><br /></td></tr>
<tr class="separator:af893df4c0a8d17cae3f8999e9bcce312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc843c9ffe0367e0e2d40bbf4f3c6053"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structur__template__t.html">ur_template_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#abc843c9ffe0367e0e2d40bbf4f3c6053">ur_ctx_create_input_template</a> (trap_ctx_t *ctx, int ifc, const char *fields, char **errstr)</td></tr>
<tr class="memdesc:abc843c9ffe0367e0e2d40bbf4f3c6053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create UniRec template and set it to input interface on specified context Creates UniRec template, same like ur_create_input_template, but context is specified.  <a href="#abc843c9ffe0367e0e2d40bbf4f3c6053">More...</a><br /></td></tr>
<tr class="separator:abc843c9ffe0367e0e2d40bbf4f3c6053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80b3d4a916e0657f57062c9477d5bd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structur__template__t.html">ur_template_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#ab80b3d4a916e0657f57062c9477d5bd0">ur_ctx_create_output_template</a> (trap_ctx_t *ctx, int ifc, const char *fields, char **errstr)</td></tr>
<tr class="memdesc:ab80b3d4a916e0657f57062c9477d5bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create UniRec template and set it to output interface on specified context Creates UniRec template, same like ur_create_output_template, but context is specified.  <a href="#ab80b3d4a916e0657f57062c9477d5bd0">More...</a><br /></td></tr>
<tr class="separator:ab80b3d4a916e0657f57062c9477d5bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27853144707572d1e6a5e0f0a37edae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#aa27853144707572d1e6a5e0f0a37edae">ur_ctx_set_output_template</a> (trap_ctx_t *ctx, int ifc, <a class="el" href="structur__template__t.html">ur_template_t</a> *tmplt)</td></tr>
<tr class="memdesc:aa27853144707572d1e6a5e0f0a37edae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UniRec template to ouput interface on specified context.  <a href="#aa27853144707572d1e6a5e0f0a37edae">More...</a><br /></td></tr>
<tr class="separator:aa27853144707572d1e6a5e0f0a37edae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21b5e95ade1d2d6993fcf9f9a6c4548"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#aa21b5e95ade1d2d6993fcf9f9a6c4548">ur_ctx_set_input_template</a> (trap_ctx_t *ctx, int ifc, <a class="el" href="structur__template__t.html">ur_template_t</a> *tmplt)</td></tr>
<tr class="memdesc:aa21b5e95ade1d2d6993fcf9f9a6c4548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UniRec template to input interface on specified context.  <a href="#aa21b5e95ade1d2d6993fcf9f9a6c4548">More...</a><br /></td></tr>
<tr class="separator:aa21b5e95ade1d2d6993fcf9f9a6c4548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac83d4ba9ab47e065f7847272beac67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structur__template__t.html">ur_template_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#a5ac83d4ba9ab47e065f7847272beac67">ur_ctx_create_bidirectional_template</a> (trap_ctx_t *ctx, int ifc_in, int ifc_out, const char *fields, char **errstr)</td></tr>
<tr class="memdesc:a5ac83d4ba9ab47e065f7847272beac67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create UniRec template and set it to input and output interface on specified context Creates UniRec template, same like ur_create_bidirectional_template, but context is specified.  <a href="#a5ac83d4ba9ab47e065f7847272beac67">More...</a><br /></td></tr>
<tr class="separator:a5ac83d4ba9ab47e065f7847272beac67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec94dfdd45a6af36f412cc06f9b0106d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structur__template__t.html">ur_template_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#aec94dfdd45a6af36f412cc06f9b0106d">ur_create_template</a> (const char *fields, char **errstr)</td></tr>
<tr class="memdesc:aec94dfdd45a6af36f412cc06f9b0106d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create UniRec template Create new UniRec template specified by a string containing names of its fields separated by commas. Example spec-string: "SRC_IP,DST_IP,SRC_PORT,DST_PORT,PROTOCOL,PACKETS" Order of fields is not important (templates with the same set of fields are equivalent). Template created by this function should be destroyed by ur_free_template.  <a href="#aec94dfdd45a6af36f412cc06f9b0106d">More...</a><br /></td></tr>
<tr class="separator:aec94dfdd45a6af36f412cc06f9b0106d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bfac2d2161cf28551a467a382feda7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#a6bfac2d2161cf28551a467a382feda7e">ur_free_template</a> (<a class="el" href="structur__template__t.html">ur_template_t</a> *tmplt)</td></tr>
<tr class="memdesc:a6bfac2d2161cf28551a467a382feda7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy UniRec template Free all memory allocated for a template created previously by ur_create_template.  <a href="#a6bfac2d2161cf28551a467a382feda7e">More...</a><br /></td></tr>
<tr class="separator:a6bfac2d2161cf28551a467a382feda7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c9d739b4b74b4547099b9095857dff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10c9d739b4b74b4547099b9095857dff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#a10c9d739b4b74b4547099b9095857dff">ur_print_template</a> (<a class="el" href="structur__template__t.html">ur_template_t</a> *tmplt)</td></tr>
<tr class="memdesc:a10c9d739b4b74b4547099b9095857dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print UniRec template Print static_size, first_dynamic and table of offsets to stdout (for debugging). If template does not contain any dynamic fields, print '-' instead. param[in] tmplt pointer to the template. <br /></td></tr>
<tr class="separator:a10c9d739b4b74b4547099b9095857dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1aeacaf5107408c58188e63406bcd1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c1aeacaf5107408c58188e63406bcd1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ur_var_change_size</b> (const <a class="el" href="structur__template__t.html">ur_template_t</a> *tmplt, void *rec, int field_id, int new_val_len)</td></tr>
<tr class="separator:a6c1aeacaf5107408c58188e63406bcd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc58a81c9f7eb5a1ec3ba36d97612068"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#adc58a81c9f7eb5a1ec3ba36d97612068">ur_set_var</a> (const <a class="el" href="structur__template__t.html">ur_template_t</a> *tmplt, void *rec, int field_id, const void *val_ptr, int val_len)</td></tr>
<tr class="memdesc:adc58a81c9f7eb5a1ec3ba36d97612068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set content of variable-length UniRec field Copy given data into variable-length UniRec field, set its offset and length in a record and move data which are behind this field. For better performance use function ur_clear_varlen, before setting all variable fields in record.  <a href="#adc58a81c9f7eb5a1ec3ba36d97612068">More...</a><br /></td></tr>
<tr class="separator:adc58a81c9f7eb5a1ec3ba36d97612068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1a56a89c745a13823db8ef01fcb07b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#a1a1a56a89c745a13823db8ef01fcb07b">ur_clear_varlen</a> (const <a class="el" href="structur__template__t.html">ur_template_t</a> *tmplt, void *rec)</td></tr>
<tr class="memdesc:a1a1a56a89c745a13823db8ef01fcb07b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear variable-length part of a record. For better performance of setting content to variable-length fields, use this function before setting of all the variable-length fields. This function will clear all the variable-length fields, so they don't have to be moved in memory during setting of them.  <a href="#a1a1a56a89c745a13823db8ef01fcb07b">More...</a><br /></td></tr>
<tr class="separator:a1a1a56a89c745a13823db8ef01fcb07b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52dad8336d06db586dd23820263f5fc2"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#a52dad8336d06db586dd23820263f5fc2">ur_rec_varlen_size</a> (const <a class="el" href="structur__template__t.html">ur_template_t</a> *tmplt, const void *rec)</td></tr>
<tr class="memdesc:a52dad8336d06db586dd23820263f5fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get size of variable sized part of UniRec record Get total size of all variable-length fields in an UniRec record.  <a href="#a52dad8336d06db586dd23820263f5fc2">More...</a><br /></td></tr>
<tr class="separator:a52dad8336d06db586dd23820263f5fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2d113dfd7629182d2b18c29c408707"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#a7e2d113dfd7629182d2b18c29c408707">ur_create_record</a> (const <a class="el" href="structur__template__t.html">ur_template_t</a> *tmplt, uint16_t max_var_size)</td></tr>
<tr class="separator:a7e2d113dfd7629182d2b18c29c408707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af622ee72f07d52a617a22be35088d77e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#af622ee72f07d52a617a22be35088d77e">ur_free_record</a> (void *record)</td></tr>
<tr class="separator:af622ee72f07d52a617a22be35088d77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5745a7f8f493f0ccd9a2099e191efd"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#a8b5745a7f8f493f0ccd9a2099e191efd">ur_get_var_as_str</a> (const <a class="el" href="structur__template__t.html">ur_template_t</a> *tmplt, const void *rec, ur_field_id_t field_id)</td></tr>
<tr class="memdesc:a8b5745a7f8f493f0ccd9a2099e191efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get variable-length UniRec field as a C string Copy data of a variable-length field from UniRec record and append '\0' character. The function allocates new memory space for the string, it must be freed using free()!  <a href="#a8b5745a7f8f493f0ccd9a2099e191efd">More...</a><br /></td></tr>
<tr class="separator:a8b5745a7f8f493f0ccd9a2099e191efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57dab204aa7abf9f0dbde89f0ee408d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#ab57dab204aa7abf9f0dbde89f0ee408d">ur_clone_record</a> (const <a class="el" href="structur__template__t.html">ur_template_t</a> *tmplt, const void *src)</td></tr>
<tr class="memdesc:ab57dab204aa7abf9f0dbde89f0ee408d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new UniRec and copy the source UniRec into it. Function creates new UniRec record and fills it with the data given by parameter.  <a href="#ab57dab204aa7abf9f0dbde89f0ee408d">More...</a><br /></td></tr>
<tr class="separator:ab57dab204aa7abf9f0dbde89f0ee408d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade89057b16556ff28d540a1f0473ab81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#ade89057b16556ff28d540a1f0473ab81">ur_copy_fields</a> (const <a class="el" href="structur__template__t.html">ur_template_t</a> *dst_tmplt, void *dst, const <a class="el" href="structur__template__t.html">ur_template_t</a> *src_tmplt, const void *src)</td></tr>
<tr class="memdesc:ade89057b16556ff28d540a1f0473ab81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from one UniRec record to another. Copies all fields present in both templates from src to dst. The function compares src_tmplt and dst_tmplt and for each field present in both templates it sets the value of field in dst to a corresponding value in src. "dst" must point to a memory of enough size.  <a href="#ade89057b16556ff28d540a1f0473ab81">More...</a><br /></td></tr>
<tr class="separator:ade89057b16556ff28d540a1f0473ab81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2182af09a35e3ba1bc868c311f3a80"><td class="memItemLeft" align="right" valign="top">ur_iter_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#afb2182af09a35e3ba1bc868c311f3a80">ur_iter_fields</a> (const <a class="el" href="structur__template__t.html">ur_template_t</a> *tmplt, ur_iter_t id)</td></tr>
<tr class="memdesc:afb2182af09a35e3ba1bc868c311f3a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over fields of a template in order of a record This function can be used to iterate over all fields of a given template. It returns ID of the next field present in the template after a given ID. If ID is set to UR_ITER_BEGIN, it returns the first fields. If no more fields are present, UR_ITER_END is returned. Example usage: ur_field_id_t id = UR_ITER_BEGIN while ((id = ur_iter_fields(&amp;tmplt, id)) != UR_ITER_END) { ... } The order of fields is given by the order in which they are defined.  <a href="#afb2182af09a35e3ba1bc868c311f3a80">More...</a><br /></td></tr>
<tr class="separator:afb2182af09a35e3ba1bc868c311f3a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8877cbc958a4943aaf720154f8338ae3"><td class="memItemLeft" align="right" valign="top">ur_iter_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#a8877cbc958a4943aaf720154f8338ae3">ur_iter_fields_record_order</a> (const <a class="el" href="structur__template__t.html">ur_template_t</a> *tmplt, int index)</td></tr>
<tr class="memdesc:a8877cbc958a4943aaf720154f8338ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over fields of a template This function can be used to iterate over all fields of a given template. It returns n-th ID of a record specified by index. If the return value is UR_ITER_END. The index is higher than count of fields in the template. Example usage: int i = 0; while ((id = ur_iter_fields(&amp;tmplt, i++)) != UR_ITER_END) { ... } The order of fields is given by the order in the record.  <a href="#a8877cbc958a4943aaf720154f8338ae3">More...</a><br /></td></tr>
<tr class="separator:a8877cbc958a4943aaf720154f8338ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60aa0708ffef7cadd5a1d7663eb8083"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#ae60aa0708ffef7cadd5a1d7663eb8083">ur_set_from_string</a> (const <a class="el" href="structur__template__t.html">ur_template_t</a> *tmpl, void *data, ur_field_id_t f_id, const char *v)</td></tr>
<tr class="memdesc:ae60aa0708ffef7cadd5a1d7663eb8083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value of a UniRec field.  <a href="#ae60aa0708ffef7cadd5a1d7663eb8083">More...</a><br /></td></tr>
<tr class="separator:ae60aa0708ffef7cadd5a1d7663eb8083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11693505eb5de52b6b2b021aeaf1a7e1"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#a11693505eb5de52b6b2b021aeaf1a7e1">ur_cpy_string</a> (const char *str)</td></tr>
<tr class="memdesc:a11693505eb5de52b6b2b021aeaf1a7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicates given string. Helper function which returns pointer to duplicated string. New string has to be freed by user.  <a href="#a11693505eb5de52b6b2b021aeaf1a7e1">More...</a><br /></td></tr>
<tr class="separator:a11693505eb5de52b6b2b021aeaf1a7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad09e518520d1791d94b29ee7af2487"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#adad09e518520d1791d94b29ee7af2487">ur_values_get_name_start_end</a> (uint32_t start, uint32_t end, int32_t value)</td></tr>
<tr class="memdesc:adad09e518520d1791d94b29ee7af2487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns name of specified value (Helper function) Helper function for ur_values_get_name. This function returns name of specified value and field, which is defined in values file. Function needs start and end index of a field.  <a href="#adad09e518520d1791d94b29ee7af2487">More...</a><br /></td></tr>
<tr class="separator:adad09e518520d1791d94b29ee7af2487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2e25e5cdee3544c54e4abf4782dfb5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unirec_8c.html#a2a2e25e5cdee3544c54e4abf4782dfb5">ur_values_get_description_start_end</a> (uint32_t start, uint32_t end, int32_t value)</td></tr>
<tr class="memdesc:a2a2e25e5cdee3544c54e4abf4782dfb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns description of specified value (Helper function) Helper function for ur_values_get_description. This function returns description of specified value and field, which is defined in values file. Function needs start and end index of a field.  <a href="#a2a2e25e5cdee3544c54e4abf4782dfb5">More...</a><br /></td></tr>
<tr class="separator:a2a2e25e5cdee3544c54e4abf4782dfb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79615b30cdec474a94bb5ce5f3eeb34f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structur__links__t.html">ur_links_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ur__links.html#ga79615b30cdec474a94bb5ce5f3eeb34f">ur_create_links</a> (const char *mask)</td></tr>
<tr class="memdesc:ga79615b30cdec474a94bb5ce5f3eeb34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and initialize links structure. Create new links structure and initialize it from link mask in string format passed by parameter. String link mask is stored in uint64_t, thne link count and link_indexes arrray is determined from it. Structure created by this function should be destroyed by ur_free_links.  <a href="group__ur__links.html#ga79615b30cdec474a94bb5ce5f3eeb34f">More...</a><br /></td></tr>
<tr class="separator:ga79615b30cdec474a94bb5ce5f3eeb34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e1802498fc99e49f98eada58ff0d883"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ur__links.html#ga7e1802498fc99e49f98eada58ff0d883">ur_free_links</a> (<a class="el" href="structur__links__t.html">ur_links_t</a> *links)</td></tr>
<tr class="memdesc:ga7e1802498fc99e49f98eada58ff0d883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy links structure. Free all memory allocated for a links structure created previously by ur_create_links.  <a href="group__ur__links.html#ga7e1802498fc99e49f98eada58ff0d883">More...</a><br /></td></tr>
<tr class="separator:ga7e1802498fc99e49f98eada58ff0d883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20fe681784b2536ad4293ed1d2932da2"><td class="memItemLeft" align="right" valign="top">INLINE_IMPL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ur__links.html#ga20fe681784b2536ad4293ed1d2932da2">ur_get_link_index</a> (<a class="el" href="structur__links__t.html">ur_links_t</a> *links, uint64_t link_bit_field)</td></tr>
<tr class="memdesc:ga20fe681784b2536ad4293ed1d2932da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get index of link (0 - (n-1)) Function gets search link_indexes array for value corresponding to passed LINK_BIT_FIELD, which should contains only one "1" value. If more ones are filled in LINK_BIT_FIELD, first from right is taken. Returns index to link_indexes array (from interval 0 - (link_count-1)) or negative value if correspondig value was not found.  <a href="group__ur__links.html#ga20fe681784b2536ad4293ed1d2932da2">More...</a><br /></td></tr>
<tr class="separator:ga20fe681784b2536ad4293ed1d2932da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga469c39d33966e8752fc53a4fba154d10"><td class="memItemLeft" align="right" valign="top">INLINE_IMPL uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ur__links.html#ga469c39d33966e8752fc53a4fba154d10">ur_get_link_bit_field_position</a> (<a class="el" href="structur__links__t.html">ur_links_t</a> *links, unsigned int index)</td></tr>
<tr class="memdesc:ga469c39d33966e8752fc53a4fba154d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get position in link_bit_field of link. Get position in link_bit_field of link specified by index of link (from interval 0 - (link_count-1)). This function is inversion to get_link_index. Returns zero if invalid index is passed.  <a href="group__ur__links.html#ga469c39d33966e8752fc53a4fba154d10">More...</a><br /></td></tr>
<tr class="separator:ga469c39d33966e8752fc53a4fba154d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0da3a3f0c637c7f49640f74a262e6a0"><td class="memItemLeft" align="right" valign="top">INLINE_IMPL uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ur__links.html#gab0da3a3f0c637c7f49640f74a262e6a0">ur_get_link_mask</a> (<a class="el" href="structur__links__t.html">ur_links_t</a> *links)</td></tr>
<tr class="memdesc:gab0da3a3f0c637c7f49640f74a262e6a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get link mask.  <a href="group__ur__links.html#gab0da3a3f0c637c7f49640f74a262e6a0">More...</a><br /></td></tr>
<tr class="separator:gab0da3a3f0c637c7f49640f74a262e6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ae62c9d1c388c62669aa5dfdeb97977"><td class="memItemLeft" align="right" valign="top">INLINE_IMPL unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ur__links.html#ga9ae62c9d1c388c62669aa5dfdeb97977">ur_get_link_count</a> (<a class="el" href="structur__links__t.html">ur_links_t</a> *links)</td></tr>
<tr class="memdesc:ga9ae62c9d1c388c62669aa5dfdeb97977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get link count.  <a href="group__ur__links.html#ga9ae62c9d1c388c62669aa5dfdeb97977">More...</a><br /></td></tr>
<tr class="separator:ga9ae62c9d1c388c62669aa5dfdeb97977"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a81f8d7af996a01f4b6e4ac086d483eb0"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><b>ur_field_type_size</b> []</td></tr>
<tr class="separator:a81f8d7af996a01f4b6e4ac086d483eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a84dc8eb5478757192b2df4004c148a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><b>ur_field_type_str</b> []</td></tr>
<tr class="separator:a2a84dc8eb5478757192b2df4004c148a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b963edd959e1d4bdd91d82807a384ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b963edd959e1d4bdd91d82807a384ba"></a>
<a class="el" href="structur__field__specs__t.html">ur_field_specs_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ur_field_specs</b></td></tr>
<tr class="separator:a8b963edd959e1d4bdd91d82807a384ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e3a2f4dff881d18a6a3c8cc67b906b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67e3a2f4dff881d18a6a3c8cc67b906b"></a>
<a class="el" href="structur__static__field__specs__t.html">ur_static_field_specs_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>UR_FIELD_SPECS_STATIC</b></td></tr>
<tr class="separator:a67e3a2f4dff881d18a6a3c8cc67b906b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6a82288d5136644ea1e3f8c68f6192"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd6a82288d5136644ea1e3f8c68f6192"></a>
const char&#160;</td><td class="memItemRight" valign="bottom"><b>UR_MEMORY_ERROR</b> [] = &quot;Memory allocation error&quot;</td></tr>
<tr class="separator:abd6a82288d5136644ea1e3f8c68f6192"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Definition of UniRec structures and functions. </p>
<dl class="section author"><dt>Author</dt><dd>Vaclav Bartos <a href="#" onclick="location.href='mai'+'lto:'+'iba'+'rt'+'osv'+'@f'+'it.'+'vu'+'tbr'+'.c'+'z'; return false;">ibart<span style="display: none;">.nosp@m.</span>osv@<span style="display: none;">.nosp@m.</span>fit.v<span style="display: none;">.nosp@m.</span>utbr<span style="display: none;">.nosp@m.</span>.cz</a> </dd>
<dd>
Zdenek Rosa <a href="#" onclick="location.href='mai'+'lto:'+'ros'+'az'+'den'+'@f'+'it.'+'cv'+'ut.'+'cz'; return false;">rosaz<span style="display: none;">.nosp@m.</span>den@<span style="display: none;">.nosp@m.</span>fit.c<span style="display: none;">.nosp@m.</span>vut.<span style="display: none;">.nosp@m.</span>cz</a> </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2015 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="af893df4c0a8d17cae3f8999e9bcce312"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int compare_fields </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>field1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>field2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare fields Compare two fields. This function is for sorting the fields in the right order. First by sizes (larger first) and then by names. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field1</td><td>Pointer to first field (field_spec_t) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field2</td><td>Pointer to second field (field_spec_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if f1 should go before f2, 0 if f1 is the same as f2, 1 otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a1a1a56a89c745a13823db8ef01fcb07b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ur_clear_varlen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structur__template__t.html">ur_template_t</a> *&#160;</td>
          <td class="paramname"><em>tmplt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear variable-length part of a record. For better performance of setting content to variable-length fields, use this function before setting of all the variable-length fields. This function will clear all the variable-length fields, so they don't have to be moved in memory during setting of them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmplt</td><td>Pointer to UniRec template. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>Pointer to the beginning of a record. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab57dab204aa7abf9f0dbde89f0ee408d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* ur_clone_record </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structur__template__t.html">ur_template_t</a> *&#160;</td>
          <td class="paramname"><em>tmplt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new UniRec and copy the source UniRec into it. Function creates new UniRec record and fills it with the data given by parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmplt</td><td>Pointer to UniRec template </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Pointer to source data (UniRec record of the same template) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a new UniRec </dd></dl>

</div>
</div>
<a class="anchor" id="ade89057b16556ff28d540a1f0473ab81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ur_copy_fields </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structur__template__t.html">ur_template_t</a> *&#160;</td>
          <td class="paramname"><em>dst_tmplt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structur__template__t.html">ur_template_t</a> *&#160;</td>
          <td class="paramname"><em>src_tmplt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy data from one UniRec record to another. Copies all fields present in both templates from src to dst. The function compares src_tmplt and dst_tmplt and for each field present in both templates it sets the value of field in dst to a corresponding value in src. "dst" must point to a memory of enough size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dst_tmplt</td><td>Pointer to destination UniRec template </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dst</td><td>Pointer to destination record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_tmplt</td><td>Pointer to source UniRec template </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Pointer to source record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a11693505eb5de52b6b2b021aeaf1a7e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ur_cpy_string </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicates given string. Helper function which returns pointer to duplicated string. New string has to be freed by user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>Pointer to the string to duplicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to duplicated string on NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a7e2d113dfd7629182d2b18c29c408707"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ur_create_record </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structur__template__t.html">ur_template_t</a> *&#160;</td>
          <td class="paramname"><em>tmplt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_var_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create UniRec record. Allocate memory for a record with given template. It allocates N+M bytes, where N is the size of static part of the record (inferred from template), and M is the size of variable part (variable-length fields), which must be provided by caller. No more than 65535 bytes is allocated (even if N+M is greater), since this is the maximal possible size of UniRec record. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmplt</td><td>Pointer to UniRec template. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_var_size</td><td>Size of variable-length part, i.e. sum of lengths of all variable-length fields. If it is not known at the time of record creation, use UR_MAX_SIZE, which allocates enough memory to hold the largest possible UniRec record (65535 bytes). Set to 0 if there are no variable-length fields in the template. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec94dfdd45a6af36f412cc06f9b0106d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structur__template__t.html">ur_template_t</a>* ur_create_template </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>errstr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create UniRec template Create new UniRec template specified by a string containing names of its fields separated by commas. Example spec-string: "SRC_IP,DST_IP,SRC_PORT,DST_PORT,PROTOCOL,PACKETS" Order of fields is not important (templates with the same set of fields are equivalent). Template created by this function should be destroyed by ur_free_template. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fields</td><td>String with names of fields delimited by comma </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">errstr</td><td>Pointer to char* string where the error message will be allocated and written in case of error. NULL if you don't need error message. In case of error, function will allocate string, which has to be freed by user. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to newly created template or NULL in case of error. </dd></dl>

</div>
</div>
<a class="anchor" id="ae1a76a48d18a09ee2f32ed638bbcbcf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structur__template__t.html">ur_template_t</a>* ur_create_template_from_ifc_spec </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ifc_data_fmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create UniRec template from data format string. Creates new UniRec template (function ur_create_template_from_ifc_spec). The string describing fields contain types and names of fields separated by commas. Example ifc_data_fmt: "uint32 FOO,uint8 BAR,float FOO2" Order of fields is not important (templates with the same set of fields are equivalent).. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifc_data_fmt</td><td>String with types and names of fields delimited by commas </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new template or NULL in case of error. </dd></dl>

</div>
</div>
<a class="anchor" id="a5ac83d4ba9ab47e065f7847272beac67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structur__template__t.html">ur_template_t</a>* ur_ctx_create_bidirectional_template </td>
          <td>(</td>
          <td class="paramtype">trap_ctx_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ifc_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ifc_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>errstr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create UniRec template and set it to input and output interface on specified context Creates UniRec template, same like ur_create_bidirectional_template, but context is specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>specified context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ifc_in</td><td>input interface number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ifc_out</td><td>output interface number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fields</td><td>String with names of fields delimited by comma </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">errstr</td><td>Pointer to char* string where the error message will be allocated and written in case of error. NULL if you don't need error message. In case of error, function will allocate string, which has to be freed by user. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to newly created template or NULL in case of error. </dd></dl>

</div>
</div>
<a class="anchor" id="abc843c9ffe0367e0e2d40bbf4f3c6053"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structur__template__t.html">ur_template_t</a>* ur_ctx_create_input_template </td>
          <td>(</td>
          <td class="paramtype">trap_ctx_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ifc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>errstr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create UniRec template and set it to input interface on specified context Creates UniRec template, same like ur_create_input_template, but context is specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>specified context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ifc</td><td>interface number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fields</td><td>String with names of fields delimited by comma </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">errstr</td><td>Pointer to char* string where the error message will be allocated and written in case of error. NULL if you don't need error message. In case of error, function will allocate string, which has to be freed by user. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to newly created template or NULL in case of error. </dd></dl>

</div>
</div>
<a class="anchor" id="ab80b3d4a916e0657f57062c9477d5bd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structur__template__t.html">ur_template_t</a>* ur_ctx_create_output_template </td>
          <td>(</td>
          <td class="paramtype">trap_ctx_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ifc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>errstr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create UniRec template and set it to output interface on specified context Creates UniRec template, same like ur_create_output_template, but context is specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>specified context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ifc</td><td>interface number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fields</td><td>String with names of fields delimited by comma </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">errstr</td><td>Pointer to char* string where the error message will be allocated and written in case of error. NULL if you don't need error message. In case of error, function will allocate string, which has to be freed by user. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to newly created template or NULL in case of error. </dd></dl>

</div>
</div>
<a class="anchor" id="aa21b5e95ade1d2d6993fcf9f9a6c4548"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ur_ctx_set_input_template </td>
          <td>(</td>
          <td class="paramtype">trap_ctx_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ifc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structur__template__t.html">ur_template_t</a> *&#160;</td>
          <td class="paramname"><em>tmplt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set UniRec template to input interface on specified context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>specified context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ifc</td><td>interface number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmplt</td><td>pointer to a template </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UR_OK if there is no problem. UR_E_MEMORY if the ID is not in the template. </dd></dl>

</div>
</div>
<a class="anchor" id="aa27853144707572d1e6a5e0f0a37edae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ur_ctx_set_output_template </td>
          <td>(</td>
          <td class="paramtype">trap_ctx_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ifc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structur__template__t.html">ur_template_t</a> *&#160;</td>
          <td class="paramname"><em>tmplt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set UniRec template to ouput interface on specified context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>specified context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ifc</td><td>interface number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmplt</td><td>pointer to a template </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UR_OK if there is no problem. UR_E_MEMORY if the ID is not in the template. </dd></dl>

</div>
</div>
<a class="anchor" id="ae9296343268e2117e4f53705c0cdf3a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ur_define_field </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ur_field_type_t&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define new UniRec field Define new UniRec field at run-time. It adds new field into existing structures. If the field already exists (name and type are equal) it only returns its ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>String with name of field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Type of field (specified by UR_TYPE_*). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ID of created or existing field. UR_E_MEMORY if there is an allocation problem. UR_E_INVALID_NAME if the name value is empty. UR_E_TYPE_MISMATCH if the name already exists, but the type is different. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b090390e3e2728d2d59168eb532633a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structur__template__t.html">ur_template_t</a>* ur_define_fields_and_update_template </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ifc_data_fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structur__template__t.html">ur_template_t</a> *&#160;</td>
          <td class="paramname"><em>tmplt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defined new fields and expand an UniRec template Define new fields (function ur_define_set_of_fields) and create new UniRec template (function ur_create_template_from_ifc_spec). The string describing fields contain types and names of fields separated by commas. Example ifc_data_fmt: "uint32 FOO,uint8 BAR,float FOO2" Order of fields is not important (templates with the same set of fields are equivalent). In case of success the given template will be destroyed and new template will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifc_data_fmt</td><td>String with types and names of fields delimited by commas </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmplt</td><td>Pointer to an existing template. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the updated template or NULL in case of error. </dd></dl>

</div>
</div>
<a class="anchor" id="adc5a6441796f8df8c63645298170f8f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ur_define_set_of_fields </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ifc_data_fmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define set of new UniRec fields Define new UniRec fields at run-time. It adds new fields into existing structures. If the field already exists and type is equal nothing will happen. If the type is not equal an error will be returned. Example ifc_data_fmt: "uint32 FOO,uint8 BAR,float FOO2". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifc_data_fmt</td><td>String containing types and names of fields delimited by comma. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UR_OK on success UR_E_MEMORY if there is an allocation problem. UR_E_INVALID_NAME if the name value is empty. UR_E_INVALID_TYPE if the type does not exist. UR_E_TYPE_MISMATCH if the name already exists, but the type is different. </dd></dl>

</div>
</div>
<a class="anchor" id="ac2b52aaae2bd3aa7d38b119a95a275e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structur__template__t.html">ur_template_t</a>* ur_expand_template </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ifc_data_fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structur__template__t.html">ur_template_t</a> *&#160;</td>
          <td class="paramname"><em>tmplt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand UniRec template Expand existing UniRec template by a string containing types and names of its fields separated by commas. Example ifc_data_fmt: "uint32 FOO,uint8 BAR,float FOO2" Order of fields is not important (templates with the same set of fields are equivalent). In case of success the given template will be destroyed and new template will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifc_data_fmt</td><td>String with types and names of fields delimited by commas </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmplt</td><td>Pointer to an existing template. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the updated template or NULL in case of error. </dd></dl>

</div>
</div>
<a class="anchor" id="af622ee72f07d52a617a22be35088d77e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ur_free_record </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>record</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free UniRec record. Free memory allocated for UniRec record. You can call system free() on the record as well, this function is there just for completeness. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">record</td><td>Pointer to the record to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6bfac2d2161cf28551a467a382feda7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ur_free_template </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structur__template__t.html">ur_template_t</a> *&#160;</td>
          <td class="paramname"><em>tmplt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy UniRec template Free all memory allocated for a template created previously by ur_create_template. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmplt</td><td>Pointer to the template. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a98890a8d9702c533d4d1d1e7921f74e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ur_get_empty_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return first empty id for new UniRec field Return first empty id for new UniRec field. If there is no space in the UniRec structures, it will increase space in the existing structures. </p>
<dl class="section return"><dt>Returns</dt><dd>ID for new field. UR_E_MEMORY (negative value) if there is an allocation problem. </dd></dl>

</div>
</div>
<a class="anchor" id="ae04af6d1916490e641f7640e440a8e7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ur_get_id_by_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ID of a field by its name Get ID of a field by its name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>String with name of a field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ID of a field. UR_E_INVALID_NAME (negative value) if the name is not known. </dd></dl>

</div>
</div>
<a class="anchor" id="a8b5745a7f8f493f0ccd9a2099e191efd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ur_get_var_as_str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structur__template__t.html">ur_template_t</a> *&#160;</td>
          <td class="paramname"><em>tmplt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ur_field_id_t&#160;</td>
          <td class="paramname"><em>field_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get variable-length UniRec field as a C string Copy data of a variable-length field from UniRec record and append '\0' character. The function allocates new memory space for the string, it must be freed using free()! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmplt</td><td>Pointer to UniRec template </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>Pointer to the beginning of a record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field_id</td><td>Identifier of a field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Requested field as a string (char*) or NULL on malloc error. It should be freed using free(). </dd></dl>

</div>
</div>
<a class="anchor" id="a31d468a710c302abfc212784c99ef889"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ur_ifc_data_fmt_to_field_names </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ifc_data_fmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses field names from data format Function parses field names from data format and returns pointer to new allocated string. Example: "type1 name1,type2 name2" =&gt; "name1,name2" New string has to be freed by user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifc_data_fmt</td><td>Pointer to the string containing data format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to string with names of fields </dd></dl>

</div>
</div>
<a class="anchor" id="a238d68dc4d1dc5b0369e907b0e2d9711"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ur_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structur__static__field__specs__t.html">ur_static_field_specs_t</a>&#160;</td>
          <td class="paramname"><em>field_specs_static</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize UniRec structures Initialize UniRec structures. Function is called during defining first own field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field_specs_static</td><td>Structure of statically-known UniRec fields. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UR_E_MEMORY if there is an allocation problem, UR_OK otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="afb2182af09a35e3ba1bc868c311f3a80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ur_iter_t ur_iter_fields </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structur__template__t.html">ur_template_t</a> *&#160;</td>
          <td class="paramname"><em>tmplt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ur_iter_t&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate over fields of a template in order of a record This function can be used to iterate over all fields of a given template. It returns ID of the next field present in the template after a given ID. If ID is set to UR_ITER_BEGIN, it returns the first fields. If no more fields are present, UR_ITER_END is returned. Example usage: ur_field_id_t id = UR_ITER_BEGIN while ((id = ur_iter_fields(&amp;tmplt, id)) != UR_ITER_END) { ... } The order of fields is given by the order in which they are defined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmplt</td><td>Template to iterate over. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Field ID returned in last iteration or UR_ITER_BEGIN to get first value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ID of the next field or UR_ITER_END if no more fields are present. </dd></dl>

</div>
</div>
<a class="anchor" id="a8877cbc958a4943aaf720154f8338ae3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ur_iter_t ur_iter_fields_record_order </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structur__template__t.html">ur_template_t</a> *&#160;</td>
          <td class="paramname"><em>tmplt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate over fields of a template This function can be used to iterate over all fields of a given template. It returns n-th ID of a record specified by index. If the return value is UR_ITER_END. The index is higher than count of fields in the template. Example usage: int i = 0; while ((id = ur_iter_fields(&amp;tmplt, i++)) != UR_ITER_END) { ... } The order of fields is given by the order in the record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmplt</td><td>Template to iterate over. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Field ID returned in last iteration or UR_ITER_BEGIN to get first value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ID of the next field or UR_ITER_END if no more fields are present. </dd></dl>

</div>
</div>
<a class="anchor" id="a52dad8336d06db586dd23820263f5fc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ur_rec_varlen_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structur__template__t.html">ur_template_t</a> *&#160;</td>
          <td class="paramname"><em>tmplt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get size of variable sized part of UniRec record Get total size of all variable-length fields in an UniRec record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmplt</td><td>Pointer to UniRec template </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the beginning of a record </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of the variable part of UniRec record. </dd></dl>

</div>
</div>
<a class="anchor" id="ae60aa0708ffef7cadd5a1d7663eb8083"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ur_set_from_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structur__template__t.html">ur_template_t</a> *&#160;</td>
          <td class="paramname"><em>tmpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ur_field_id_t&#160;</td>
          <td class="paramname"><em>f_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set value of a UniRec field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmpl</td><td>Pointer to UniRec template </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Pointer to the beginning of a record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f_id</td><td>Identifier of a field. It must be a constant beginning with UR_, not its numeric value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The value the field should be set to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, non-zero otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="adc58a81c9f7eb5a1ec3ba36d97612068"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ur_set_var </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structur__template__t.html">ur_template_t</a> *&#160;</td>
          <td class="paramname"><em>tmplt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>field_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>val_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set content of variable-length UniRec field Copy given data into variable-length UniRec field, set its offset and length in a record and move data which are behind this field. For better performance use function ur_clear_varlen, before setting all variable fields in record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmplt</td><td>Pointer to UniRec template </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>Pointer to the beginning of a record. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field_id</td><td>Identifier of a field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val_ptr</td><td>Pointer to data which should be copied into the record. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val_len</td><td>Length of the copied data in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UR_OK if there is no problem. UR_E_INVALID_FIELD_ID if the ID is not in the template. </dd></dl>

</div>
</div>
<a class="anchor" id="abfbfcce0fe6729ceb692d09541336c33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ur_template_string_delimiter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structur__template__t.html">ur_template_t</a> *&#160;</td>
          <td class="paramname"><em>tmplt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive data from interface with given context Receive data with specified template from libtrap interface with specified context. If the receiving template is subset of sending template, it will define new fields and expand receiving template. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ifc_num</td><td>index of libtrap interface </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>pointer to memory where the data will be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>size of allocated space for data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmplt</td><td>pointer to input template </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return value of trap_ctx_recvGet string of a template Get names and sizes of fields separated by given delimiter. Return string has to be freed by user. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmplt</td><td>Pointer to UniRec template </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String </dd></dl>

</div>
</div>
<a class="anchor" id="a3b7d40d098716943f035185d26aeff29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ur_undefine_field </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undefine UniRec field by its name Undefine UniRec field created at run-time. It erases given field from UniRec structures and the field ID can be used for another field. By undefining field, all templates which were using the undefined field, has to be recreated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of a field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UR_E_MEMORY if there is an allocation problem. UR_E_INVALID_PARAMETER if the field was not created at run-time or the field_id does not exist. </dd></dl>

</div>
</div>
<a class="anchor" id="a0d8940c1aab20e50ab84da99715322fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ur_undefine_field_by_id </td>
          <td>(</td>
          <td class="paramtype">ur_field_id_t&#160;</td>
          <td class="paramname"><em>field_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undefine UniRec field by its id Undefine UniRec field created at run-time. It erases given field from UniRec structures and the field ID can be used for another field. By undefining field, all templates which were using the undefined field, has to be recreated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field_id</td><td>Identifier of a field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UR_E_MEMORY if there is an allocation problem. UR_E_INVALID_PARAMETER if the field was not created at run-time or the field_id does not exist. </dd></dl>

</div>
</div>
<a class="anchor" id="a2a2e25e5cdee3544c54e4abf4782dfb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* ur_values_get_description_start_end </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns description of specified value (Helper function) Helper function for ur_values_get_description. This function returns description of specified value and field, which is defined in values file. Function needs start and end index of a field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>Index of first item to search the value in ur_values array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>Index of last item to search the value in ur_values array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value of an item to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to string or NULL if the value was not found </dd></dl>

</div>
</div>
<a class="anchor" id="adad09e518520d1791d94b29ee7af2487"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* ur_values_get_name_start_end </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns name of specified value (Helper function) Helper function for ur_values_get_name. This function returns name of specified value and field, which is defined in values file. Function needs start and end index of a field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>Index of first item to search the value in ur_values array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>Index of last item to search the value in ur_values array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value of an item to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to string or NULL if the value was not found </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a81f8d7af996a01f4b6e4ac086d483eb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ur_field_type_size[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    -1, </div>
<div class="line">    -1, </div>
<div class="line">    1, </div>
<div class="line">    1, </div>
<div class="line">    1, </div>
<div class="line">    2, </div>
<div class="line">    2, </div>
<div class="line">    4, </div>
<div class="line">    4, </div>
<div class="line">    8, </div>
<div class="line">    8, </div>
<div class="line">    4, </div>
<div class="line">    8, </div>
<div class="line">    16, </div>
<div class="line">    8, </div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2a84dc8eb5478757192b2df4004c148a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* ur_field_type_str[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    <span class="stringliteral">&quot;string&quot;</span>, </div>
<div class="line">    <span class="stringliteral">&quot;bytes&quot;</span>, </div>
<div class="line">    <span class="stringliteral">&quot;char&quot;</span>, </div>
<div class="line">    <span class="stringliteral">&quot;uint8&quot;</span>, </div>
<div class="line">    <span class="stringliteral">&quot;int8&quot;</span>, </div>
<div class="line">    <span class="stringliteral">&quot;uint16&quot;</span>, </div>
<div class="line">    <span class="stringliteral">&quot;int16&quot;</span>, </div>
<div class="line">    <span class="stringliteral">&quot;uint32&quot;</span>, </div>
<div class="line">    <span class="stringliteral">&quot;int32&quot;</span>, </div>
<div class="line">    <span class="stringliteral">&quot;uint64&quot;</span>, </div>
<div class="line">    <span class="stringliteral">&quot;int64&quot;</span>, </div>
<div class="line">    <span class="stringliteral">&quot;float&quot;</span>, </div>
<div class="line">    <span class="stringliteral">&quot;double&quot;</span>, </div>
<div class="line">    <span class="stringliteral">&quot;ipaddr&quot;</span>, </div>
<div class="line">    <span class="stringliteral">&quot;time&quot;</span>, </div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
