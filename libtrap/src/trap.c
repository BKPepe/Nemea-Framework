/**
 * \file trap.c
 * \brief TRAP library base.
 * \author Vaclav Bartos <ibartosv@fit.vutbr.cz>
 * \author Tomas Cejka <cejkat@cesnet.cz>
 * \author Jan Neuzil <neuzija1@fit.cvut.cz>
 * \author Marek Svepes <svepemar@fit.cvut.cz>
 * \date 2013
 * \date 2014
 */
/*
 * Copyright (C) 2013,2014 CESNET
 *
 * LICENSE TERMS
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name of the Company nor the names of its contributors
 *    may be used to endorse or promote products derived from this
 *    software without specific prior written permission.
 *
 * ALTERNATIVELY, provided that this notice is retained in full, this
 * product may be distributed under the terms of the GNU General Public
 * License (GPL) version 2 or later, in which case the provisions
 * of the GPL apply INSTEAD OF those given above.
 *
 * This software is provided ``as is'', and any express or implied
 * warranties, including, but not limited to, the implied warranties of
 * merchantability and fitness for a particular purpose are disclaimed.
 * In no event shall the company or contributors be liable for any
 * direct, indirect, incidental, special, exemplary, or consequential
 * damages (including, but not limited to, procurement of substitute
 * goods or services; loss of use, data, or profits; or business
 * interruption) however caused and on any theory of liability, whether
 * in contract, strict liability, or tort (including negligence or
 * otherwise) arising in any way out of the use of this software, even
 * if advised of the possibility of such damage.
 *
 */
#include <stdint.h>
#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>
#include <getopt.h>
#include <pthread.h>
#include <signal.h>
#include <semaphore.h>
#include <unistd.h>
#include <errno.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <stdint.h>
#include <inttypes.h>

#include "../include/libtrap/trap.h"
#include "trap_internal.h"
#include "trap_error.h"
#include "trap_ifc.h"
#include "ifc_dummy.h"
#include "ifc_tcpip.h"
#include "ifc_tcpip_internal.h"

/**
 * Version of libtrap
 *
 * Used from config.h that is generated by the configure script.
 */
const char trap_version[] __attribute__((used)) = PACKAGE_VERSION;

/**
 * Git revision of libtrap
 *
 * Used from config.h that is generated by the configure script.
 */
const char trap_git_version[] __attribute__((used)) = GIT_VERSION;

/**
 * NULL terminated array of supported IFC types.
 */
char trap_ifc_type_supported[] = {
   TRAP_IFC_TYPE_GENERATOR,
   TRAP_IFC_TYPE_BLACKHOLE,
   TRAP_IFC_TYPE_TCPIP,
   TRAP_IFC_TYPE_UNIX,
   TRAP_IFC_TYPE_SERVICE,
   0
};

trap_ctx_priv_t * trap_glob_ctx = NULL;

/* for backwards compatibility */
int trap_last_error = TRAP_E_OK;
/* for backwards compatibility */
const char *trap_last_error_msg = NULL;

/** Share semaphore between process? 0 for share between threads only. */
#define SEM_PSHARED  0

/** Size of multiresult array for reading from more than one interface at once. */
#define IN_IFC_RESULTS_SIZE(ctx) ((ctx)->num_ifc_in * sizeof(trap_multi_result_t))

/** String representation of interface direction (Input/Output) */
#define ifcdir2str(type) (((type) == TRAPIFC_OUTPUT) ? "Output" : "Input")

static char *get_param_by_delimiter(const char *source, char **dest, const char delimiter);
static int compare_timeouts(const void *a, const void *b);
int trap_ctx_get_multi_data(trap_ctx_t *ctx, uint32_t ifc_mask, const void **data, uint16_t *size);
void create_service_thread(trap_ctx_priv_t * ctx, const char * params);

///////////////////////////////////////////////////////////////////////////////

/**
 * \defgroup buffering Buffering sublayer
 * @{
 */

/**
 * \brief Check content of buffer, iterate over message headers
 * \param [in] buffer      start of buffer
 * \param [in] buffer_size size of buffer
 * \return 0 on success, number of errors otherwise
 */
int trap_check_buffer_content(void *buffer, uint32_t buffer_size)
{
   uint32_t offset, check_mess_counter = 0;
   uint16_t *check_mess_header;
   int errors = 0;
   void *check_mess_pointer;
   for (offset = 0, check_mess_header = check_mess_pointer = buffer;
         ((offset < buffer_size) && (offset < TRAP_IFC_MESSAGEQ_SIZE));) {
      check_mess_counter++;
      /* go to next size, skip header + payload */
      offset += sizeof(*check_mess_header) + (*check_mess_header);
      check_mess_pointer += sizeof(*check_mess_header) + (*check_mess_header);
      check_mess_header = (uint16_t *) check_mess_pointer;
   }
   if (offset != buffer_size) {
      VERBOSE(CL_ERROR, "Not enough data or some headers are malformed.");
      errors++;
      return errors;
   }
   return errors;
}

/**
 * Read data from buffer or receive data into buffer if buffer is empty
 *
 * \param[in,out] ctx   pointer to the private libtrap context data (trap_ctx_init())
 * \param[in] ifc_idx   index of input interface
 * \param[out] data     pointer to received message
 * \param[out] size     size of message
 * \param[in] timeout   TRAP_WAIT | TRAP_NO_WAIT | timeout
 */
static inline int trap_read_from_buffer(trap_ctx_priv_t *ctx, uint32_t ifc_idx, const void **data, uint16_t *size, int timeout)
{
   int result = TRAP_E_TIMEOUT;
   /* pointer to current message header */
   uint32_t tempbufheader = 0;

   /* pointer to current message payload */
   void *bp = ctx->in_ifc_list[ifc_idx].buffer;
   pthread_mutex_lock(&ctx->in_ifc_list[ifc_idx].ifc_mtx);
   if ((ctx->in_ifc_list[ifc_idx].buffer_full == 0) || (ctx->in_ifc_list[ifc_idx].buffer_full > TRAP_IFC_MESSAGEQ_SIZE)) {
      /* get new data and store into buffer, set buffer_full size */
      ctx->in_ifc_list[ifc_idx].buffer_pointer = ctx->in_ifc_list[ifc_idx].buffer;
      result = ctx->in_ifc_list[ifc_idx].recv(ctx->in_ifc_list[ifc_idx].priv, bp, &tempbufheader, timeout);
#ifdef BUFFERING_CHECK_HEADERS
      if (trap_check_buffer_content(bp, tempbufheader) != 0) {
         VERBOSE(CL_ERROR, "Buffer is not valid.");
      }
#endif
      if (result == TRAP_E_OK) {
         ctx->counter_recv_buffer[ifc_idx]++;

         ctx->in_ifc_list[ifc_idx].buffer_full = tempbufheader;
         ctx->in_ifc_list[ifc_idx].buffer_pointer = ctx->in_ifc_list[ifc_idx].buffer;
         DEBUG_BUF(VERBOSE(CL_VERBOSE_LIBRARY, "read received new buffer new bf %"PRIu32" %p",
                ctx->in_ifc_list[ifc_idx].buffer_full,
                ctx->in_ifc_list[ifc_idx].buffer_pointer));
         #ifdef TESTBUFFERING
         VERBOSE(CL_VERBOSE_OFF, "Received buffer of size %u.", ctx->in_ifc_list[ifc_idx].buffer_full);
         #endif
      } else {
         goto exit;
      }
   }

   if (ctx->in_ifc_list[ifc_idx].buffer_full > 0) {
      /* get message from buffer */
      (*size) = *((uint16_t *) ctx->in_ifc_list[ifc_idx].buffer_pointer);
      (*data) = (ctx->in_ifc_list[ifc_idx].buffer_pointer + sizeof(*size));
      /* decrease buffer_full size by returned payload and its header */
      ctx->in_ifc_list[ifc_idx].buffer_full -= (*size + sizeof(*size));
      ctx->in_ifc_list[ifc_idx].buffer_pointer += (*size) + sizeof(*size);
      DEBUG_BUF(VERBOSE(CL_VERBOSE_LIBRARY, "read from buffer %"PRIu16" B skip %"PRIu64" B, new bf %"PRIu32" %p",
                (*size),
                (*size + sizeof(*size)),
                ctx->in_ifc_list[ifc_idx].buffer_full,
                ctx->in_ifc_list[ifc_idx].buffer_pointer));
      result = TRAP_E_OK;
   } else {
      (*size) = 0;
   }
exit:
   pthread_mutex_unlock(&ctx->in_ifc_list[ifc_idx].ifc_mtx);
   return result;
}

static void insert_into_buffer(trap_output_ifc_t *priv, const void *data, const uint16_t size)
{
   if ((priv->buffer_occupied == 0) && priv->buffer_index < (TRAP_IFC_MESSAGEQ_SIZE - sizeof(trap_buffer_header_t))) {
      uint16_t *msize = (uint16_t *) &priv->buffer[priv->buffer_index];
      (*msize) = size;
      memcpy((void *) (msize + 1), data, size);
      priv->buffer_index += size + sizeof size;
   }
}
static inline int trap_store_into_buffer(trap_ctx_priv_t *ctx, unsigned int ifc, const void *data, uint16_t size, int timeout, char flush)
{
   /* Declaration of variables, we can have small buffer, initialization after checking the condition. */
   uint32_t freespace, needed_size = size + sizeof(size);
   int result;

   if (ctx->out_ifc_list[ifc].ifc_type == TRAP_IFC_TYPE_BLACKHOLE) {
      return TRAP_E_OK;
   }

   /* Can we put message at least into empty buffer? In the worst case, we could end up with SEGFAULT -> rather skip with error */
   if (needed_size > TRAP_IFC_MESSAGEQ_SIZE) {
      return trap_errorf(ctx, TRAP_E_MEMORY, "Buffer is too small for this message. Skipping...");
   }

   if (flush != 0) {
      /* Autoflush call, trying to lock section, maybe interface is waiting for clients -> rather skip than block the whole thread. */
      if (pthread_mutex_trylock(&ctx->out_ifc_list[ifc].ifc_mtx) != 0) {
         return TRAP_E_OK;
      }
   } else {
      /* Lock this section at first before sending whole buffer. */
      pthread_mutex_lock(&ctx->out_ifc_list[ifc].ifc_mtx);
   }
   /* initialization in locked section, otherwise autoflush can send buffer which has been already sent */
   if (ctx->out_ifc_list[ifc].buffer_index <= TRAP_IFC_MESSAGEQ_SIZE) {
      freespace = TRAP_IFC_MESSAGEQ_SIZE - ctx->out_ifc_list[ifc].buffer_index;
   } else {
      freespace = 0;
   }
   result = TRAP_E_TIMEOUT;

   /* Is this a autoflush call? If we have empty buffer, we do not send anything. */
   if (flush != 0) {
      if (ctx->out_ifc_list[ifc].buffer_index != 0) {
#ifdef BUFFERING_CHECK_HEADERS
         if (trap_check_buffer_content(ctx->out_ifc_list[ifc].buffer, ctx->out_ifc_list[ifc].buffer_index) != 0) {
            VERBOSE(CL_ERROR, "Buffer is not valid.");
         }
#endif
         DEBUG_BUF(VERBOSE(CL_VERBOSE_LIBRARY, "sending by autoflush %"PRIu32" B from %p", ctx->out_ifc_list[ifc].buffer_index, ctx->out_ifc_list[ifc].buffer));

         ctx->out_ifc_list[ifc].buffer_occupied = 1;
         trap_buffer_header_t *h = (trap_buffer_header_t *) ctx->out_ifc_list[ifc].buffer_header;
         h->data_length = htonl(ctx->out_ifc_list[ifc].buffer_index);
         result = ctx->out_ifc_list[ifc].send(ctx->out_ifc_list[ifc].priv, ctx->out_ifc_list[ifc].buffer_header,
                                              ctx->out_ifc_list[ifc].buffer_index + sizeof(trap_buffer_header_t), timeout);

         if (trap_ctx_get_client_count(ctx, ifc) == 0) {
            ctx->out_ifc_list[ifc].buffer_occupied = 0;
         }

         if (result == TRAP_E_OK) {
            ctx->counter_send_buffer[ifc]++;
            ctx->out_ifc_list[ifc].buffer_index = 0;
            ctx->out_ifc_list[ifc].buffer_occupied = 0;
            DEBUG_BUF(VERBOSE(CL_VERBOSE_LIBRARY, "Sending partial buffer invoked by autoflush timeout on iterface %d", ifc));
         } else {
            VERBOSE(CL_VERBOSE_LIBRARY, "Autoflush was not successful.");
         }
      }
      goto fn_exit;
   }
   /* we send buffer before timeout, no need to flush it */
   ctx->out_ifc_list[ifc].bufferflush = 1;

   if ((freespace >= needed_size) && (ctx->out_ifc_list[ifc].bufferswitch == 1)) {
      /* we have enough space, buffering is enabled and size is not "flush" */

      insert_into_buffer(&ctx->out_ifc_list[ifc], data, size);

      result = TRAP_E_OK;

   } else {
      /* not enough space */

#ifdef BUFFERING_CHECK_HEADERS
      if (trap_check_buffer_content(ctx->out_ifc_list[ifc].buffer, ctx->out_ifc_list[ifc].buffer_index) != 0) {
         VERBOSE(CL_ERROR, "Buffer is not valid.");
      }
#endif

      DEBUG_BUF(VERBOSE(CL_VERBOSE_LIBRARY, "sending %"PRIu32" B from %p", ctx->out_ifc_list[ifc].buffer_index, ctx->out_ifc_list[ifc].buffer));

#ifdef BUFFERING_CREATE_DUMPS
      char *n = NULL;
      if (asprintf(&n, "store-buffers-dump%04"PRIu64, ctx->counter_send_buffer[ifc]) != -1) {
         mkdir(n, 0700);
         ctx->out_ifc_list[ifc].create_dump(ctx->out_ifc_list[ifc].priv, ifc, n);
         free(n);
      }
#endif

      if (ctx->out_ifc_list[ifc].bufferswitch == 0) {
         insert_into_buffer(&ctx->out_ifc_list[ifc], data, size);
      }

      ctx->out_ifc_list[ifc].buffer_occupied = 1;
      trap_buffer_header_t *h = (trap_buffer_header_t *) ctx->out_ifc_list[ifc].buffer_header;
      h->data_length = htonl(ctx->out_ifc_list[ifc].buffer_index);
      result = ctx->out_ifc_list[ifc].send(ctx->out_ifc_list[ifc].priv, ctx->out_ifc_list[ifc].buffer_header,
                                           ctx->out_ifc_list[ifc].buffer_index + sizeof(trap_buffer_header_t), timeout);

      /* if the buffer was successfuly sent OR we have no client: */
      if (result == TRAP_E_OK || result == TRAP_E_IO_ERROR) {
         if (result == TRAP_E_OK) {
            /*
             * buffer was successfuly sent but we still have current message pending-unstored
             * it will be the first message in buffer
             */
            ctx->counter_send_buffer[ifc]++;
         } else {
            /* we had no client but we can propagate either OK or TIMEOUT: */
            result = TRAP_E_TIMEOUT;
         }
         /* buffer will be cleaned */
         ctx->out_ifc_list[ifc].buffer_index = 0;
         ctx->out_ifc_list[ifc].buffer_occupied = 0;
         /* buffer was successfuly send but we still have current message pending-unstored
          * it will be the first message in buffer */
         if (ctx->out_ifc_list[ifc].bufferswitch == 1) {
            insert_into_buffer(&ctx->out_ifc_list[ifc], data, size);
         }
      }
   }
   if (trap_ctx_get_client_count(ctx, ifc) == 0) {
      ctx->out_ifc_list[ifc].buffer_occupied = 0;
   }

fn_exit:
   pthread_mutex_unlock(&ctx->out_ifc_list[ifc].ifc_mtx);
   return result;
}

/**
 * @}
 */

struct reader_threads_arg {
   trap_ctx_priv_t *ctx;
   int thread_index;
};

/**
 * Function of reader-thread.
 *
 * \param[in] arg struct reader_threads_arg with context and thread id - used as the index in ctx->in_ifc_list, in_ifc_results
 * \return NULL
 */
void *reader_threads_fn(void *arg)
{
   struct reader_threads_arg *argdata = (struct reader_threads_arg *) arg;
   trap_ctx_priv_t *ctx = NULL;
   int thread_id;
   if (argdata == NULL) {
      pthread_exit(NULL);
   }
   ctx = argdata->ctx;
   thread_id = argdata->thread_index;
   int retval;
   do {
      sem_wait(&ctx->reader_threads[thread_id].sem);
      if (pthread_rwlock_rdlock(&ctx->context_lock) != 0) {
         VERBOSE(CL_ERROR, "Locking of context failed. %s", __func__);
      }
      if (ctx->terminated == 1) {
         pthread_rwlock_unlock(&ctx->context_lock);
         break;
      }
      pthread_rwlock_unlock(&ctx->context_lock);
      /* call recv of my IFC and let it store results into multi-result array */
      #ifndef DISABLE_BUFFERING
      retval = trap_read_from_buffer(ctx, thread_id, (const void **) &ctx->in_ifc_results[thread_id].message,
                                           &ctx->in_ifc_results[thread_id].message_size,
                                           ctx->get_data_timeout);
      #else
      uint32_t recvsize = 0;
      retval = ctx->in_ifc_list[thread_id].recv(ctx->in_ifc_list[thread_id].priv,
                                           ctx->in_ifc_list[thread_id].buffer,
                                           &recvsize,
                                           ctx->get_data_timeout);
      /* if sender uses buffering, we are loosing data! in addition, data can be corrupted in this case!!! */
      ctx->in_ifc_results[thread_id].message_size = (uint16_t) recvsize;
      ctx->in_ifc_results[thread_id].message = ctx->in_ifc_list[thread_id].buffer;
      #endif

      ctx->in_ifc_results[thread_id].result_code = retval;
      /* inform collector about finished job */
      sem_post(&ctx->sem_collector);
      if (pthread_rwlock_rdlock(&ctx->context_lock) != 0) {
         VERBOSE(CL_ERROR, "Locking of context failed. %s", __func__);
      }
      if (ctx->terminated == 1) {
         pthread_rwlock_unlock(&ctx->context_lock);
         break;
      }
      pthread_rwlock_unlock(&ctx->context_lock);
   } while (1);
   free(arg);
   pthread_exit(NULL);
}
/**
 * Function to initialize or change the array of structures with information about timeouts
 * on output interfaces.
 *
 * @param[in,out] ctx         pointer to the private libtrap context data (trap_ctx_init())
 * @return Number of output interfaces, where the timeout is set.
 */
static inline int trap_init_ifcs_timeouts(trap_ctx_priv_t *ctx)
{
   int i, idx, res;
   struct out_ifc_timeout_s *out_ifc_timeout = ctx->ifc_autoflush_timeout;
   idx = 0;
   for (i = 0; i < ctx->num_ifc_out; i++) {
      if ((ctx->out_ifc_list[i].timeout != TRAP_NO_AUTO_FLUSH) && (ctx->out_ifc_list[i].bufferswitch != 0)) {
         out_ifc_timeout[idx].idx = i;
         // Try lock updating of timeout, it could be changing, do not block
         res = pthread_mutex_trylock(&ctx->out_ifc_list[i].ifc_mtx);
         out_ifc_timeout[idx].tm = ctx->out_ifc_list[i].timeout;
         if (res == 0)
            pthread_mutex_unlock(&ctx->out_ifc_list[i].ifc_mtx);
         idx++;
      }
   }
   // All changes updated, set to zero
   if (pthread_rwlock_wrlock(&ctx->context_lock) != 0) {
      VERBOSE(CL_ERROR, "Locking of context failed. %s", __func__);
   }
   ctx->ifc_change = 0;
   pthread_rwlock_unlock(&ctx->context_lock);
   return idx;
}

/**
 * Handle the timeouts on output interfaces and flush buffer after timeout is reached.
 *
 *
 * @return NULL
 */
static void *trap_automatic_flush_thr(void *arg)
{
   int i, n;
   int64_t usec;
   trap_ctx_priv_t *ctx = (trap_ctx_priv_t *) arg;

   n = trap_init_ifcs_timeouts(ctx);

   while (1) {
      if (pthread_rwlock_rdlock(&ctx->context_lock) != 0) {
         VERBOSE(CL_ERROR, "Locking of context failed. %s", __func__);
         break;
      }
      if (ctx->terminated == 1) {
         pthread_rwlock_unlock(&ctx->context_lock);
         break;
      }
      // Checking if automatic flushing or buffering was changed or disabled
      if (ctx->ifc_change == 1) {
         pthread_rwlock_unlock(&ctx->context_lock);
         n = trap_init_ifcs_timeouts(ctx);
      } else {
         pthread_rwlock_unlock(&ctx->context_lock);
      }

      // Sort array by timeout if we have more than one output interface
      if (n != 0) {
         if (n > 1) {
            qsort(ctx->ifc_autoflush_timeout, n, sizeof(struct out_ifc_timeout_s), compare_timeouts);
         }
         usec = ctx->ifc_autoflush_timeout[0].tm;
         VERBOSE(CL_VERBOSE_LIBRARY, "Autoflush thread is going to sleep for %ld microseconds.", usec);
         if (sleep(usec/1000000) != 0) {
            if (pthread_rwlock_rdlock(&ctx->context_lock) != 0) {
               VERBOSE(CL_ERROR, "Locking of context failed. %s", __func__);
               break;
            }
            if (ctx->terminated == 1) {
               pthread_rwlock_unlock(&ctx->context_lock);
               break;
            }
            pthread_rwlock_unlock(&ctx->context_lock);
         }
         if (usleep(usec%1000000) == -1) {
            if (pthread_rwlock_rdlock(&ctx->context_lock) != 0) {
               VERBOSE(CL_ERROR, "Locking of context failed. %s", __func__);
               break;
            }
            if (ctx->terminated == 1) {
               pthread_rwlock_unlock(&ctx->context_lock);
               break;
            }
            pthread_rwlock_unlock(&ctx->context_lock);
         }

         // Check all interfaces if timeout has elapsed, otherwise break
         for (i = 0; i < n; i++) {
            ctx->ifc_autoflush_timeout[i].tm -= usec;
            if (ctx->ifc_autoflush_timeout[i].tm == 0) {
               pthread_mutex_lock(&ctx->out_ifc_list[i].ifc_mtx);
               if (ctx->out_ifc_list[ctx->ifc_autoflush_timeout[i].idx].bufferflush == 0) {
                  pthread_mutex_unlock(&ctx->out_ifc_list[i].ifc_mtx);
                  // No event on the interface, flushing the buffer
                  trap_ctx_send_flush((trap_ctx_t *) ctx, i);
                  ctx->counter_autoflush[ctx->ifc_autoflush_timeout[i].idx]++;
               }
               else {
                  // Buffer was sent before timeout has elapsed, no need to flush the buffer
                  ctx->out_ifc_list[ctx->ifc_autoflush_timeout[i].idx].bufferflush = 0;
                  pthread_mutex_unlock(&ctx->out_ifc_list[i].ifc_mtx);
               }
               // Updating of timeout, it could be changing
               pthread_mutex_lock(&ctx->out_ifc_list[i].ifc_mtx);
               ctx->ifc_autoflush_timeout[i].tm = ctx->out_ifc_list[ctx->ifc_autoflush_timeout[i].idx].timeout;
               pthread_mutex_unlock(&ctx->out_ifc_list[i].ifc_mtx);
            } else {
               continue;
            }
         }
      } else {
         // Sleep for defined time, default 2 seconds
         if (sleep(TRAP_NO_IFC_SLEEP)) {
            break;
         }
      }
   }

   pthread_exit(NULL);
}

/** Initialization function.
 * Create and initialize all interfaces. This function parses command-line
 * arguments; it extracts agruments it needs to set up interfaces and returns
 * the rest (argc and argv are modified).
 * @param[in,out] argc Pointer to number of command-line arguments.
 * @param[in,out] argv Command-line arguments.
 * @param[out] ifc_spec Structure with specification of interface types and
 *                      their parameters.
 * @return Error code (0 on success)
 */
int trap_parse_params(int *argc, char **argv, trap_ifc_spec_t *ifc_spec)
{
   int i;
   char *ifc_spec_str = NULL;
   char *ifc_type = NULL;

   /* initialization of ifc_spec */
   memset(ifc_spec, 0, sizeof(trap_ifc_spec_t));

   // Look for -h (or --help) parameter
   for (i = 0; i < *argc; i++) {
      if (strcmp(argv[i], "-h") == 0 || strcmp(argv[i], "--help") == 0) {
         // Remove parameter from argv and break
         int j;
         for (j = i; j+1 < *argc; j++)
            argv[j] = argv[j+1];
         *argc -= 1;
         //return trap_error(TRAP_E_HELP);
         return TRAP_E_HELP;
      }
   }

   // Extract -i parameter (interface specifier)
   for (i = 0; i < *argc-1; i++) {
      if (argv[i] && strcmp(argv[i], "-i") == 0) {
         ifc_spec_str = argv[i+1];
         // Remove parameters from argv
         int j;
         for (j = i; j+2 < *argc; j++)
            argv[j] = argv[j+2];
         *argc -= 2;
         break;
      }
   }
   if (ifc_spec_str == NULL) {
      //return trap_errorf(ctx, TRAP_E_BADPARAMS, "Interface specifier (option -i) not found.");
      trap_last_error = TRAP_E_BADPARAMS;
      trap_last_error_msg = default_err_msg[TRAP_E_BADPARAMS];
      return TRAP_E_BADPARAMS;
   }

   // Extract verbose level parameter (-v, -vv, -vvv)
   for (i = 0; i < *argc; i++) {
      // If param mathes -v, -vv or -vvv, set verbosity level
      if (strcmp(argv[i], "-v") == 0)
         trap_set_verbose_level(0);
      else if (strcmp(argv[i], "-vv") == 0)
         trap_set_verbose_level(1);
      else if (strcmp(argv[i], "-vvv") == 0)
         trap_set_verbose_level(2);
      else
         continue;
      // Remove parameter from argv and break
      int j;
      for (j = i; j+1 < *argc; j++)
         argv[j] = argv[j+1];
      *argc -= 1;
      break;
   }

   // Parse interface specifier
   char *ifc_params_str = get_param_by_delimiter(ifc_spec_str, &ifc_spec->types, ';');
   if (ifc_spec->types == NULL) {
      trap_last_error = TRAP_E_MEMORY;
      trap_last_error_msg = default_err_msg[TRAP_E_MEMORY];
      return TRAP_E_MEMORY;
      //return trap_error(TRAP_E_MEMORY);
   }

   /* check for unsupported IFCs */
   for (i = 0; ifc_spec->types[i] != 0; ++i) {
      for (ifc_type = trap_ifc_type_supported; *ifc_type != 0; ++ifc_type) {
         if (*ifc_type == ifc_spec->types[i]) {
            break;
         }
      }
      if (*ifc_type == 0) {
         /* not found */
         free(ifc_spec->types);
         ifc_spec->types = NULL;
         trap_last_error = TRAP_E_BADPARAMS;
         trap_last_error_msg = "Unsupported IFC type.";
         return TRAP_E_BADPARAMS;
      }
   }

   // Get number of interfaces
   int num_ifcs = strlen(ifc_spec->types);

   // Allocate ifc_params array
   ifc_spec->params = calloc(num_ifcs, sizeof(char *));
   if (ifc_spec->params == NULL) {
      free(ifc_spec->types);
      ifc_spec->types = NULL;
      trap_last_error = TRAP_E_MEMORY;
      trap_last_error_msg = default_err_msg[TRAP_E_MEMORY];
      return TRAP_E_MEMORY;
      //return trap_error(TRAP_E_MEMORY);
   }

   // Extract all parameter strings
   for (i = 0; i < num_ifcs; i++) {
      ifc_params_str = get_param_by_delimiter(ifc_params_str, &ifc_spec->params[i], ';');
      if (ifc_spec->params[i] == NULL) {
         if (ifc_spec->params != NULL) {
            while (--i >= 0) {
               if (ifc_spec->params[i] != NULL) {
                  free(ifc_spec->params[i]);
                  ifc_spec->params[i] = NULL;
               }
            }
            free(ifc_spec->params);
            ifc_spec->params = NULL;
         }
         if (ifc_spec->types != NULL) {
            free(ifc_spec->types);
            ifc_spec->types = NULL;
         }
         trap_last_error = TRAP_E_BADPARAMS;
         trap_last_error_msg = default_err_msg[TRAP_E_BADPARAMS];
         return TRAP_E_BADPARAMS;
         //return trap_errorf(ctx, TRAP_E_BADPARAMS, "Wrong format of interface specifier.");
      }
   }

   // Check whether everything was read
   if (ifc_params_str != NULL) {
      VERBOSE(CL_WARNING, "Redundant interface parameters.");
      if (ifc_spec->params != NULL) {
         while (--i >= 0) {
            if (ifc_spec->params[i] != NULL) {
               free(ifc_spec->params[i]);
               ifc_spec->params[i] = NULL;
            }
         }
         free(ifc_spec->params);
         ifc_spec->params = NULL;
      }
      //"Wrong format of interface specifier."
      return TRAP_E_BADPARAMS;
   }

   trap_last_error = TRAP_E_OK;
   trap_last_error_msg = default_err_msg[TRAP_E_OK];
   return TRAP_E_OK;
   //return trap_error(TRAP_E_OK);
}

/** Destructor of trap_ifc_spec_t structure.
 * @param[in] ifc_spec trap_ifc_spec_t structure to clear.
 * @return  Error code (0 on success)
 */
int trap_free_ifc_spec(trap_ifc_spec_t ifc_spec)
{
   int i;
   if (ifc_spec.types == NULL) {
      return trap_error(trap_glob_ctx, TRAP_E_BADPARAMS);
   }
   if (ifc_spec.params != NULL) {
      for (i = 0; i < strlen(ifc_spec.types); i++) {
         if (ifc_spec.params[i] != NULL) {
            free(ifc_spec.params[i]);
            ifc_spec.params[i] = NULL;
         }
      }
      free(ifc_spec.params);
      ifc_spec.params = NULL;
   }
   free(ifc_spec.types);
   return trap_error(trap_glob_ctx, TRAP_E_OK);
}

void trap_free_ctx_t(trap_ctx_priv_t **ctx);

/** Initialization function.
 * Create and initialize all interfaces.
 * @param[in] module_info Pointer to struct containing info about the module.
 * @param[in] ifc_spec Structure with specification of interface types and
 *                      their parameters.
 * @return Error code (0 on success)
 */
int trap_init(const trap_module_info_t *module_info, trap_ifc_spec_t ifc_spec)
{
   if ((trap_glob_ctx != NULL) && (trap_glob_ctx->initialized != 0)) {
      return trap_error(trap_glob_ctx, TRAP_E_INITIALIZED);
   }
   trap_glob_ctx = trap_ctx_init(module_info, ifc_spec);
   if (trap_glob_ctx == NULL) {
      return TRAP_E_MEMORY;
   }
   if (trap_glob_ctx->trap_last_error != TRAP_E_OK) {
      trap_last_error_msg = trap_glob_ctx->trap_last_error_msg;
      trap_last_error = trap_glob_ctx->trap_last_error;
      trap_finalize();
      trap_free_ctx_t(&trap_glob_ctx);

      return trap_last_error;
   }
   return trap_glob_ctx->trap_last_error;
}


/** Function to terminate module's operation.
 * This function stops all read/write operations on all interfaces.
 * Any waiting in trap_get_data and trap_send_data is interrupted and these
 * functions return immediately with TRAP_E_TERMINATED.
 * Any call of trap_get_data or trap_send_data after call of this function
 * returns TRAP_E_TERMINATED.
 *
 * This function is used to terminate module's operation (asynchronously), e.g.
 * in SIGTERM handler.
 * @return Always TRAP_E_OK (0).
 */
int trap_terminate()
{
   int ret = trap_ctx_terminate(trap_glob_ctx);
   if (trap_glob_ctx != NULL) {
      trap_last_error_msg = trap_glob_ctx->trap_last_error_msg;
      trap_last_error = trap_glob_ctx->trap_last_error;
   } else {
      trap_last_error_msg = "No allocated global context.";
      trap_last_error = ret;
   }
   return ret;
}



int trap_finalize()
{
   int ret;
   ret = trap_ctx_finalize(((trap_ctx_t **) &trap_glob_ctx));
   if (ret != TRAP_E_OK) {
      if (trap_glob_ctx != NULL) {
         trap_last_error_msg = trap_glob_ctx->trap_last_error_msg;
         trap_last_error = trap_glob_ctx->trap_last_error;
      } else {
         trap_last_error_msg = "No allocated global context.";
         trap_last_error = ret;
      }
   }
   return ret;
}


/**
 * \brief Get pointer to data stored in buffer (with headers) and mark buffer as clean.
 *
 */
void trap_get_internal_buffer(trap_ctx_priv_t *ctx, uint16_t ifc_idx, const void **data, uint32_t *size)
{
   (*data) = ctx->in_ifc_list[ifc_idx].buffer;
   (*size) = ctx->in_ifc_list[ifc_idx].buffer_full;

   /* mark internal buffer as free for next reading */
   ctx->in_ifc_list[ifc_idx].buffer_pointer = ctx->in_ifc_list[ifc_idx].buffer;
   ctx->in_ifc_list[ifc_idx].buffer_full = 0;
}

/** Read data from input interface.
 * Read a record from one of interfaces specified by `ifc_mask` and store
 * pointer to it into `data`. If `ifc_mask` contains more than 1 interface,
 * data are retrieve via parallel threads. In this case, resulting `data` is array
 * of `trap_multi_result` number of elements same as number of interfaces (returned `size` is size of
 * array in bytes --- number_of_interfaces * sizeof(trap_multi_result)).
 * If data are not available on any of specified
 * interfaces, wait until data are available or `timeout` microseconds elapses.
 * If `timeout` is equal to TRAP_WAIT, wait indefinitely. If `timeout` is equal to TRAP_NO_WAIT,
 * function is non-blocking with no timeout.
 * When function returs due to timeout, contents of `data` and `size` are undefined.
 * @param[in] ifc_mask Mask of interfaces to listen on (if *i*-th bit is set, interface *i* is enabled).
 * @param[out] data Pointer to data, you have to cast it to appropriate structure.
 * @param[out] size Number of bytes of data.
 * @param[in] timeout Timeout in microseconds.
 * @return Error code - 0 on success, TRAP_E_TIMEOUT if timeout elapses.
 */
int trap_get_data(uint32_t ifc_mask, const void **data, uint16_t *size, int timeout)
{
   int counter;
   int selected_mask = 0x1;
   int res;
   /* timeout */
   for (counter = 0; counter < trap_glob_ctx->num_ifc_in; ++counter) {
      if ((ifc_mask & selected_mask) != 0) {
         trap_glob_ctx->in_ifc_list[counter].datatimeout = timeout;
      }
      selected_mask <<= 1;
   }
   /* receive data */
   if (trap_glob_ctx->num_ifc_in > 1) {
      res = trap_ctx_get_multi_data((trap_ctx_t *) trap_glob_ctx, ifc_mask, data, size);
      trap_last_error_msg = trap_glob_ctx->trap_last_error_msg;
      trap_last_error = trap_glob_ctx->trap_last_error;
   } else {
      /* libtrap initialized with only one IFC */
      res = trap_ctx_recv((trap_ctx_t *) trap_glob_ctx, 0, data, size);
      trap_last_error_msg = trap_glob_ctx->trap_last_error_msg;
      trap_last_error = trap_glob_ctx->trap_last_error;
   }
   return res;
}

#define SEND_DATA() do { \
   int res = trap_ctx_send((trap_ctx_t *) trap_glob_ctx, ifcidx, data, size); \
   trap_last_error_msg = trap_glob_ctx->trap_last_error_msg;  \
   trap_last_error = trap_glob_ctx->trap_last_error; \
   return res; \
} while (0);

int trap_send_data(unsigned int ifcidx, const void *data, uint16_t size, int timeout)
{
   trap_glob_ctx->out_ifc_list[ifcidx].datatimeout = timeout;
   SEND_DATA()
}

int trap_send(uint32_t ifcidx, const void *data, uint16_t size)
{
   SEND_DATA()
}

#undef SEND_DATA

int trap_recv(uint32_t ifcidx, const void **data, uint16_t *size)
{
   int res;
   res = trap_ctx_recv((trap_ctx_t *) trap_glob_ctx, ifcidx, data, size);
   trap_last_error_msg = trap_glob_ctx->trap_last_error_msg;
   trap_last_error = trap_glob_ctx->trap_last_error;
   return res;
}


/** Set verbosity level.
 * Verbosity levels are:
 *   - -3 - errors
 *   - -2 - warnings
 *   - -1 - notices (default)
 *   -  0 - verbose
 *   -  1 - more verbose
 *   -  2 - even more verbose
 *
 * @param[in] level Desired level of verbosity.
 */
void trap_set_verbose_level(int level)
{
   trap_verbose = level;
}

/** Get verbosity level.
 * See trap_set_verbose_level for list of levels.
 * @return Verbosity level currently set in the library.
 */
int trap_get_verbose_level()
{
   return trap_verbose;
}

extern char *environ[];

void trap_json_print_string(char *str)
{
   printf("\"");
   if (str != NULL) {
      while (*str != 0) {
         if (*str == '\n') {
            printf("\\n");
         } else if (*str == '\t') {
            printf(" ");
         } else {
            printf("%c", *str);
         }
         str++;
      }
   }
   printf("\"");
}

void trap_convert_module_info_to_json(const trap_module_info_t * info)
{
   int i = 0;

   printf("{\"name\":");
   trap_json_print_string(info->name);
   printf(",\"description\":");
   trap_json_print_string(info->description);
   printf(",\"num_ifc_in\":%u,\"num_ifc_out\":%u,\"params\":[",
         info->num_ifc_in, info->num_ifc_out);

   while (info->params[i] != NULL) {
      if (i != 0) {
         printf(",");
      }
      printf("{\"short_opt\":\"%c\",\"long_opt\":", info->params[i]->short_opt);
      trap_json_print_string(info->params[i]->long_opt);
      printf(",\"description\":");
      trap_json_print_string(info->params[i]->description);
      printf(",\"argument_type\":");
      trap_json_print_string(info->params[i]->argument_type);
      printf(",\"mandatory_argument\": %d}", info->params[i]->param_required_argument);
      i++;
   }
   printf("]}\n");
}

/** Print common TRAP help message.
 * The help message contains information from module_info and describes common
 * TRAP command-line parameters.
 * @param[in] module_info Pointer to struct containing info about the module.
 */
void trap_print_help(const trap_module_info_t *module_info)
{
   char *pager = NULL, *output_format = NULL;
   int pager_fds[2];
   pid_t p;

   /* Decide which format of output will be used according to the enviroment variable */
   output_format = getenv("LIBTRAP_OUTPUT_FORMAT");
   if (output_format != NULL) {
      if (strcmp(output_format, "json") == 0) {
         trap_convert_module_info_to_json(module_info);
         return;
      }
   }

   pager = getenv("PAGER");
   if (pager == NULL) {
      goto output;
   }

   if (pipe(pager_fds) < 0) {
      fprintf(stderr, "pipe() failed.");
      goto output;
   }

   p = fork();
   if (p < 0) {
      fprintf(stderr, "fork() failed.");
      goto output;
   } else if (p == 0) {
      /* child - pager */
      close(pager_fds[0]); /* close unused read end!!! important */
      /* set write end of pipe as stdout for this child process */
      dup2(pager_fds[1], STDOUT_FILENO);
      close(pager_fds[1]); /* important */
      goto output;
   } else {
      /* parent */
      char *args[] = {pager, NULL};
      close(pager_fds[1]); /* close unused write end!!! important */
      /* set read end of pipe as stdin for this process */
      dup2(pager_fds[0], STDIN_FILENO);
      close(pager_fds[0]); /* already redirected to stdin */
      execvp(args[0], args);
      perror("exec failed");
      exit(EXIT_FAILURE);
   }
   return;
output:
   printf("TRAP module, libtrap version: %s %s\n", trap_version, trap_git_version);
   printf("Name: %s\n", module_info->name);
   if (module_info->num_ifc_in == -1) {
      printf("Inputs: variable\n");
   } else {
      printf("Inputs: %u\n", (module_info->num_ifc_in));
   }
   if (module_info->num_ifc_out == -1) {
      printf("Outputs: variable\n");
   } else {
      printf("Outputs: %u\n", module_info->num_ifc_out);
   }
   printf("Description:\n");
   printf("%s\n", module_info->description);
   printf("\n");
   printf("Common TRAP parameters:\n");
   printf("  -h           Print this message.\n");
   printf("  -i IFC_SPEC  Specification of interface types and their parameters, see below\n");
   printf("               (mandatory parameter).\n");
   printf("  -v           Be verbose.\n");
   printf("  -vv          Be more verbose.\n");
   printf("  -vvv         Be even more verbose.\n");
   printf("\n");
   trap_print_ifc_spec_help();
}

/** Print help about interface specifier.
 * Prints help message about format of interface specifier and description of
 * all available interface types.
 */
void trap_print_ifc_spec_help()
{
   printf("Format of IFC_SPEC: <ifc_types>;<params1>;<params2>;...;<paramsN>\n");
   printf("  N is number of module's interfaces (both input and output).\n");
   printf("  <ifc_types> is a string of length N where i-th character specifies a type of\n");
   printf("    the i-th interface (input interfaces first, then output interfaces).\n");
   printf("  <paramsI> specifies parameters for I-th interface. Format is specific for each\n");
   printf("    interface type.\n");
   printf("\n");
   printf("Interface types available:\n");
   printf("  TCP interface ('t')\n");
   printf("    Communicates through a TCP socket. Output interface listens on a given port,\n");
   printf("    input interface connects to it. There may be more than one input interfaces\n");
   printf("    connected to one output interface, every input interface will get the same data.\n");
   printf("    Parameters when used as INPUT interface:\n");
   printf("      <hostname or ip>,<port>\n");
   printf("      Hostname/IP and port to connect to must be specified.\n");
   printf("    Parameters when used as OUTPUT interface:\n");
   printf("      <port>,<max_num_of_clients>\n");
   printf("      Port to listen on and maximal number of clients (input interfaces) allowed\n");
   printf("      must be specified.\n");
   printf("  TCP interface - UNIX socket ('u')\n");
   printf("    Communicates through a UNIX socket. Output interface listens on a given port,\n");
   printf("    input interface connects to it. There may be more than one input interfaces\n");
   printf("    connected to one output interface, every input interface will get the same data.\n");
   printf("    Parameters are the same as for TCP interface ('t').\n");
   printf("  Blackhole interface ('b')\n");
   printf("    Can be used as OUTPUT interface only. Does nothing, everything which is sent\n");
   printf("    by this interface is dropped. It has no parameters.\n");
   printf("\n");
   printf("Example usage for a module with one input interface and two output interfaces:\n");
   printf("  ./my_module -i \"tbt;localhost,12345;;23456,5\"\n");
   printf("  The input interface will connect to localhost:12345. The first output\n");
   printf("  interface is unused (all data send there will be dropped), the second output\n");
   printf("  interface will provide data on port 23456, to which another module can connect\n");
   printf("  its input interface.\n");
   printf("\n");
   printf("Note: Don't forget to enclose IFC_SPEC in quotation marks, otherwise a shell\n");
   printf("will treat semicolons as command separators.\n");
}

////////////////////////////

/**
 * \brief Splitter of *params* string.
 * Cut the first param, copy it into *dest* and returns pointer to the start of following
 * parameter.
 * \param[in] source  source string, typically *params*
 * \param[out] dest  destination string, target of first paramater copying
 * \param[in] delimiter  separator of values in *params*
 * \return Pointer to the start of following parameter (char after delimiter). \note If NULL, no other parameter is present or error during allocation occured.
 */
char *trap_get_param_by_delimiter(const char *source, char **dest, const char delimiter)
{
   char *param_end = NULL;
   unsigned int param_size = 0;

   if (source == NULL) {
      return NULL;
   }

   param_end = strchr(source, delimiter);
   if (param_end == NULL) {
      /* no delimiter found, copy the whole source */
      *dest = strdup(source);
      return NULL;
   }

   param_size = param_end - source;
   *dest = (char *) calloc(1, param_size + 1);
   if (*dest == NULL) {
      return (NULL);
   }
   strncpy(*dest, source, param_size);
   return param_end + 1;
}

inline char *get_param_by_delimiter(const char *source, char **dest, const char delimiter)
{
   return trap_get_param_by_delimiter(source, dest, delimiter);
}

inline void trap_set_timeouts(int timeout, struct timeval *tm, struct timespec *tmnblk)
{
   if ((timeout == TRAP_NO_WAIT) || (timeout == TRAP_HALFWAIT)) {
      tm->tv_sec  = 0;
      tm->tv_usec = 0;
   } else if (timeout > TRAP_HALFWAIT) {
      if (timeout == TRAP_WAIT) {
         tm->tv_sec  = 0;
         tm->tv_usec = 0;
      } else {
         tm->tv_sec  = timeout / 1000000;
         tm->tv_usec = timeout % 1000000;
      }
   } else {
      VERBOSE(CL_ERROR, "Setting timeout to %d failed", timeout);
      return;
   }
   if (tmnblk == NULL) {
      /* we do not need tmnblk */
      return;
   }
   /* tmnblk is used for timed wait on semaphore, this needs absolute time... */
   if (clock_gettime(CLOCK_REALTIME, tmnblk) == -1) {
      /* handle error */
      tmnblk->tv_sec = 0;
      tmnblk->tv_nsec = 0;
   }

   if (tm->tv_usec != 0) {
      tmnblk->tv_nsec = (long) tm->tv_usec * 1000;
   } else {
      tmnblk->tv_nsec = 0;
   }
   tmnblk->tv_sec += (time_t) (tm->tv_sec + (tm->tv_usec / 1000000));
}

int trap_ifcctl(int8_t type, uint32_t ifcidx, int32_t request, ... /* arg */)
{
   va_list ap;
   int res;
   va_start(ap, request);
   res = trap_ctx_vifcctl(trap_glob_ctx, type, ifcidx, request, ap);
   va_end(ap);
   return res;
}

void trap_send_flush(uint32_t ifc)
{
   trap_ctx_send_flush((trap_ctx_t *) trap_glob_ctx, ifc);
}

static int compare_timeouts (const void *a, const void *b)
{
   return ((*(struct out_ifc_timeout_s *)a).tm - (*(struct out_ifc_timeout_s *)b).tm);
}

/**
 * \addtogroup contextapi Context API
 * @{
 */

trap_ctx_priv_t *trap_create_ctx_t()
{
        trap_ctx_priv_t *ctx = calloc(1, sizeof(trap_ctx_priv_t));
        /* space for vars init with non-zero values */
        return ctx;
}

void trap_free_ctx_t(trap_ctx_priv_t **ctx)
{
   int i;
   trap_ctx_priv_t *c = (*ctx);
   if ((ctx == NULL) || (c == NULL)) {
      return;
   }

   /* free allocated counters */
   free(c->counter_autoflush);
   c->counter_autoflush = NULL;
   free(c->counter_send_buffer);
   c->counter_send_buffer = NULL;
   free(c->counter_recv_message);
   c->counter_recv_message = NULL;
   free(c->counter_send_message);
   c->counter_send_message = NULL;
   free(c->counter_recv_buffer);
   c->counter_recv_buffer = NULL;

   // Destroy all interfaces
   if ((c->num_ifc_in > 0) && (c->in_ifc_list != NULL)) {
      for (i = 0; i < c->num_ifc_in; i++) {
         if (c->in_ifc_list[i].buffer != NULL) {
            free(c->in_ifc_list[i].buffer);
            c->in_ifc_list[i].buffer = NULL;
         }
         if (c->in_ifc_list[i].destroy != NULL) {
            c->in_ifc_list[i].destroy(c->in_ifc_list[i].priv);
         }
         pthread_mutex_destroy(&c->in_ifc_list[i].ifc_mtx);
      }
      free(c->in_ifc_list);
      if (c->in_ifc_results != NULL) {
         free(c->in_ifc_results);
         c->in_ifc_results = NULL;
      }
   }

   if ((c->num_ifc_out > 0) && (c->out_ifc_list != NULL)) {
      for (i = 0; i < c->num_ifc_out; i++) {
         if (c->out_ifc_list[i].destroy != NULL) {
            c->out_ifc_list[i].destroy(c->out_ifc_list[i].priv);
         }
         if (c->out_ifc_list[i].buffer_header != NULL) {
            free(c->out_ifc_list[i].buffer_header);
            c->out_ifc_list[i].buffer_header = NULL;
         }
         pthread_mutex_destroy(&c->out_ifc_list[i].ifc_mtx);
      }
      free(c->out_ifc_list);
      c->out_ifc_list = NULL;
      free(c->ifc_autoflush_timeout);
      c->ifc_autoflush_timeout = NULL;
   }

   // Free threads and semaphores
   if (c->reader_threads != NULL) {
      for (i = 0; i < c->num_ifc_in; ++i) {
         sem_post(&c->reader_threads[i].sem);
         pthread_join(c->reader_threads[i].thr, NULL);
         sem_destroy(&c->reader_threads[i].sem);
      }
      free(c->reader_threads);
   }

   if (c->in_ifc_results != NULL) {
      free(c->in_ifc_results);
      c->in_ifc_results = NULL;
   }

   c->terminated = 1;
   pthread_rwlock_destroy(&c->context_lock);

   free(c);
   (*ctx) = NULL;
}

int trap_ctx_terminate(trap_ctx_t *ctx)
{
   int i;
   trap_ctx_priv_t *c = (trap_ctx_priv_t *) ctx;
   if ((c == NULL) || (c->terminated != 0)) {
      return TRAP_E_OK;
   }
   c->terminated = 1;

   for (i = 0; i < c->num_ifc_in; i++) {
      if (c->in_ifc_list[i].terminate != NULL) {
         c->in_ifc_list[i].terminate(c->in_ifc_list[i].priv);
      } else {
         return trap_errorf(c, TRAP_E_MEMORY, "IFC was not initialized.");
      }
   }
   for (i = 0; i < c->num_ifc_out; i++) {
      if (c->out_ifc_list[i].terminate != NULL) {
         c->out_ifc_list[i].terminate(c->out_ifc_list[i].priv);
      } else {
         return trap_errorf(c, TRAP_E_MEMORY, "IFC was not initialized.");
      }
   }
   return TRAP_E_OK;
}

int trap_ctx_recv(trap_ctx_t *ctx, uint32_t ifcidx, const void **data, uint16_t *size)
{
   trap_ctx_priv_t *c = (trap_ctx_priv_t *) ctx;
   if ((c == NULL) || (c->initialized == 0)) {
      return trap_error(c, TRAP_E_NOT_INITIALIZED);
   }
   if (pthread_rwlock_rdlock(&c->context_lock) != 0) {
      VERBOSE(CL_ERROR, "Locking of context failed. %s", __func__);
      if (c->terminated == 1) {
         return trap_error(c, TRAP_E_TERMINATED);
      }
   }
   if (c->terminated) {
      pthread_rwlock_unlock(&c->context_lock);
      return trap_error(c, TRAP_E_TERMINATED);
   }
   pthread_rwlock_unlock(&c->context_lock);
   if (ifcidx >= c->num_ifc_in) {
      return trap_errorf(c, TRAP_E_NOT_SELECTED, "No input ifc to get data from...");
   }
   c->counter_recv_message[ifcidx]++;
   if ((c->in_ifc_list[ifcidx].recv != NULL) && (c->in_ifc_list[ifcidx].priv != NULL)) {
#ifndef DISABLE_BUFFERING
      return trap_read_from_buffer(c, ifcidx, data, size, c->in_ifc_list[ifcidx].datatimeout);
#else
      uint32_t newsize = 0;
      result = c->in_ifc_list[ifcidx].recv(c->in_ifc_list[ifcidx].priv, c->in_ifc_list[ifcidx].buffer, &newsize, c->in_ifc_list[ifcidx].datatimeout);
      (*size) = newsize;
      (*data) = c->in_ifc_list[ifcidx].buffer;
      return result;
#endif
   } else {
      return trap_errorf(c, TRAP_E_MEMORY, "IFC was not initialized.");
   }
}

int trap_ctx_get_multi_data(trap_ctx_t *ctx, uint32_t ifc_mask, const void **data, uint16_t *size)
{
   uint32_t counter = 0;
   uint32_t selected_mask = 1;
   uint32_t selected_ifcs = 0;
   uint32_t selected_idx = 0;
   /* max number of interfaces (given by mask size) = 32 */
   uint32_t selected_ifc_arr[sizeof(ifc_mask) * 8];
   trap_ctx_priv_t *c = (trap_ctx_priv_t *) ctx;

   if (!c->initialized) {
      return trap_error(c, TRAP_E_NOT_INITIALIZED);
   }
   if (pthread_rwlock_rdlock(&c->context_lock) != 0) {
      VERBOSE(CL_ERROR, "Locking of context failed. %s", __func__);
      if (c->terminated == 1) {
         return trap_error(c, TRAP_E_TERMINATED);
      }
   }
   if (c->terminated) {
      pthread_rwlock_unlock(&c->context_lock);
      return trap_error(c, TRAP_E_TERMINATED);
   }
   pthread_rwlock_unlock(&c->context_lock);
   if (ifc_mask == 0) {
      /* no interface selected by mask... */
      return trap_errorf(c, TRAP_E_OK, "No interface selected by mask that is probably wrong.");
   }

   for (counter = 0; counter < c->num_ifc_in; ++counter) {
      if ((ifc_mask & selected_mask) != 0) {
         selected_ifc_arr[selected_ifcs++] = counter;
         selected_idx = counter;
      }
      c->in_ifc_results[counter].result_code = TRAP_E_TIMEOUT;
      selected_mask <<= 1;
   }
   if (selected_ifcs == 1) {
      /* get data from one IFC */
      c->counter_recv_message[selected_idx]++;
      c->in_ifc_results[counter].result_code = trap_ctx_recv(ctx, selected_idx,
            (const void **) &c->in_ifc_results[selected_idx].message, &c->in_ifc_results[selected_idx].message_size);
      (*data) = c->in_ifc_results;
      (*size) = IN_IFC_RESULTS_SIZE(c);
      return trap_error(c, c->in_ifc_results[counter].result_code);
   } else if (selected_ifcs > 1) {
      // selected_ifcs initialized to 1
      c->get_data_timeout = c->in_ifc_list[selected_ifc_arr[0]].datatimeout;
      for (counter = 0; counter < selected_ifcs; ++counter) {
         // unblock all selected threads
         c->counter_recv_message[counter]++;
         /* get minimal timeout of selected ifcs */
         if (c->get_data_timeout > c->in_ifc_list[selected_ifc_arr[counter]].datatimeout) {
            c->get_data_timeout = c->in_ifc_list[selected_ifc_arr[counter]].datatimeout;
         }
         sem_post(&c->reader_threads[selected_ifc_arr[counter]].sem);
      }
      for (counter = 0; counter < selected_ifcs; ++counter) {
         // wait for all reader-threads
         sem_wait(&c->sem_collector);
      }
      (*data) = c->in_ifc_results;
      (*size) = IN_IFC_RESULTS_SIZE(c);
      return trap_error(c, TRAP_E_OK);
   }
   return trap_errorf(c, TRAP_E_NOT_SELECTED, "No input ifc to get data from...");
}

/** Cleanup function.
 * Disconnect all interfaces and do all necessary cleanup.
 * @return Error code
 */
int trap_ctx_finalize(trap_ctx_t **ctx)
{
   int i;
   if ((ctx == NULL) || (*ctx == NULL)) {
      return TRAP_E_NOT_INITIALIZED;
   }
   trap_ctx_priv_t *c = *((trap_ctx_priv_t **)ctx);
   if (c == NULL) {
      return TRAP_E_NOT_INITIALIZED;
   }
   if (!c->initialized) {
      free(c);
      (*ctx) = NULL;
      return TRAP_E_NOT_INITIALIZED;
   }

   /* force flush of buffer for every output ifc */
   if (c->num_ifc_out > 0) {
      for (i = 0; i < c->num_ifc_out; i++) {
         trap_ctx_ifcctl((trap_ctx_t *) c, TRAPIFC_OUTPUT, i, TRAPCTL_AUTOFLUSH_TIMEOUT, TRAP_NO_AUTO_FLUSH);
         trap_ctx_ifcctl((trap_ctx_t *) c, TRAPIFC_OUTPUT, i, TRAPCTL_SETTIMEOUT, TRAP_HALFWAIT);
         trap_ctx_send_flush((trap_ctx_t *) c, i);
      }
   }

   /* check if libtrap is terminated and terminate if not */
   if (pthread_rwlock_rdlock(&c->context_lock) != 0) {
      VERBOSE(CL_ERROR, "Locking of context failed. %s", __func__);
   }
   if (c->terminated == 0) {
      pthread_rwlock_unlock(&c->context_lock);
      trap_ctx_terminate(c);
   } else {
      pthread_rwlock_unlock(&c->context_lock);
   }

   if (c->num_ifc_out > 0) {
      for (i = 0; i < c->num_ifc_out; i++) {
         trap_ctx_ifcctl((trap_ctx_t *) c, TRAPIFC_OUTPUT, i, TRAPCTL_AUTOFLUSH_TIMEOUT, TRAP_NO_AUTO_FLUSH);
      }
   }
   // Destroy timeouts handling thread for output interfaces
   if (c->timeout_thread_initialized == 1) {
      pthread_cancel(c->timeout_thread);
      pthread_join(c->timeout_thread, NULL);
   }
   if (c->service_thread_initialized == 1) {
      pthread_cancel(c->service_thread);
      pthread_join(c->service_thread, NULL);
   }
   trap_free_ctx_t(&c);
   (*ctx) = NULL;

   return TRAP_E_OK;
}

int trap_ctx_send(trap_ctx_t *ctx, unsigned int ifc, const void *data, uint16_t size)
{
   trap_ctx_priv_t *c = (trap_ctx_priv_t *) ctx;

   if (!c || !c->initialized) {
      return trap_error(c, TRAP_E_NOT_INITIALIZED);
   }
   if (pthread_rwlock_rdlock(&c->context_lock) != 0) {
      VERBOSE(CL_ERROR, "Locking of context failed. %s", __func__);
      if (c->terminated == 1) {
         return trap_error(c, TRAP_E_TERMINATED);
      }
   }
   if (c->terminated) {
      pthread_rwlock_unlock(&c->context_lock);
      return trap_error(c, TRAP_E_TERMINATED);
   }
   pthread_rwlock_unlock(&c->context_lock);
   if (ifc >= c->num_ifc_out) {
      return trap_error(c, TRAP_E_BAD_IFC_INDEX);
   }
   c->counter_send_message[ifc]++;

   #ifndef DISABLE_BUFFERING
   /* handle buffering */
   return trap_store_into_buffer(c, ifc, data, size, c->out_ifc_list[ifc].datatimeout, 0);
   #else
   return c->out_ifc_list[ifc].send(c->out_ifc_list[ifc].priv, data, size, c->out_ifc_list[ifc].datatimeout);
   #endif
}

/**
 * Switch of supported IFC types, place to call input IFC constructor.
 *
 * \param[in,out] ctx     pointer to context
 * \param[in] ifc_spec    IFC specifiers
 * \param[in] idx         index into IFC array
 * \return EXIT_SUCCESS on success, EXIT_FAILURE on error.
 */
static inline int trapifc_in_construct(trap_ctx_priv_t *ctx, trap_ifc_spec_t *ifc_spec, int idx)
{
   switch (ifc_spec->types[idx]) {
   case TRAP_IFC_TYPE_GENERATOR:
      /* if (create_generator_ifc("\x10||==::test::==||", &ctx->in_ifc_list[idx]) != TRAP_E_OK)  */
      if (create_generator_ifc(ctx, ifc_spec->params[idx], &ctx->in_ifc_list[idx]) != TRAP_E_OK) {
         VERBOSE(CL_ERROR, "Initialization of GENERATOR input interface no. %i failed.", idx);
         goto error;
      }
      break;
   case TRAP_IFC_TYPE_TCPIP:
      if (create_tcpip_receiver_ifc(ctx, ifc_spec->params[idx], &ctx->in_ifc_list[idx], TRAP_IFC_TCPIP) != TRAP_E_OK) {
         VERBOSE(CL_ERROR, "Initialization of TCPIP input interface no. %i failed.", idx);
         goto error;
      }
      break;
   case TRAP_IFC_TYPE_UNIX:
      if (create_tcpip_receiver_ifc(ctx, ifc_spec->params[idx], &ctx->in_ifc_list[idx], TRAP_IFC_TCPIP_UNIX) != TRAP_E_OK) {
         VERBOSE(CL_ERROR, "Initialization of UNIX input interface no. %i failed.", idx);
         goto error;
      }
      break;
   default:
      VERBOSE(CL_ERROR, "Unknown input interface type '%c'.", ifc_spec->types[idx]);
      goto error;
   }
   return EXIT_SUCCESS;
error:
   return EXIT_FAILURE;
}

/**
 * Switch of supported IFC types, place to call output IFC constructor.
 *
 * \param[in,out] ctx     pointer to context
 * \param[in] ifc_spec    IFC specifiers
 * \param[in] idx         index into IFC array
 * \return EXIT_SUCCESS on success, EXIT_FAILURE on error.
 */
static inline int trapifc_out_construct(trap_ctx_priv_t *ctx, trap_ifc_spec_t *ifc_spec, int idx)
{
   switch (ifc_spec->types[ctx->num_ifc_in + idx]) {
   case TRAP_IFC_TYPE_BLACKHOLE:
      if (create_blackhole_ifc(ctx, NULL, &ctx->out_ifc_list[idx]) != TRAP_E_OK) {
         VERBOSE(CL_ERROR, "Initialization of BLACKHOLE output interface no. %i failed.", idx);
         goto error;
      }
      break;
   case TRAP_IFC_TYPE_TCPIP:
      if (create_tcpip_sender_ifc(ctx, ifc_spec->params[ctx->num_ifc_in + idx],
                                  &ctx->out_ifc_list[idx], TRAP_IFC_TCPIP) != TRAP_E_OK) {
         VERBOSE(CL_ERROR, "Initialization of TCPIP output interface no. %i failed.", idx);
         goto error;
      }
      break;
   case TRAP_IFC_TYPE_UNIX:
      if (create_tcpip_sender_ifc(ctx, ifc_spec->params[ctx->num_ifc_in + idx],
                                  &ctx->out_ifc_list[idx], TRAP_IFC_TCPIP_UNIX) != TRAP_E_OK) {
         VERBOSE(CL_ERROR, "Initialization of UNIX output interface no. %i failed.", idx);
         goto error;
      }
      break;
   default:
      VERBOSE(CL_ERROR, "Unknown output interface type '%c'.", ifc_spec->types[ctx->num_ifc_in + idx]);
      goto error;
   }
   return EXIT_SUCCESS;
error:
   return EXIT_FAILURE;
}

/**
 *
 * \return context, NULL when allocation failed.
 */
trap_ctx_t *trap_ctx_init(const trap_module_info_t *module_info, trap_ifc_spec_t ifc_spec)
{
   int i;
   if ((ifc_spec.types == NULL) || (ifc_spec.params == NULL)) {
      return NULL;
   }
   trap_ctx_priv_t *ctx = trap_create_ctx_t();
   if (ctx == NULL) {
      return NULL;
   }
   /* create mutex protecting session list */
   pthread_rwlockattr_t lock_attrs;
   pthread_rwlockattr_init(&lock_attrs);
   /* rwlock is shared only with threads in this process */
   pthread_rwlockattr_setpshared(&lock_attrs, PTHREAD_PROCESS_PRIVATE);
   if (pthread_rwlock_init(&ctx->context_lock, &lock_attrs) != 0) {
      VERBOSE(CL_ERROR, "Initialization of mutex failed: %d (%s)", errno, strerror(errno));
      pthread_rwlockattr_destroy(&lock_attrs);
      free(ctx);
      return NULL;
   }
   pthread_rwlockattr_destroy(&lock_attrs);
   /* ctx is initialized by 0x00 */
   trap_error(ctx, TRAP_E_OK); // set "no error"

   // Check whether parameters matches module's numbers of interfaces
   ctx->num_ifc_in = module_info->num_ifc_in;
   ctx->num_ifc_out = module_info->num_ifc_out;

   int strlen_ifc_types = strlen(ifc_spec.types);
   int service_ifc = 0;
   for (i=0; i<strlen_ifc_types; i++) {
      if (ifc_spec.types[i] == 's') {
         if (i == strlen_ifc_types-1) {
            service_ifc = 1;
         } else {
            printf("Parameter \"s\" in ifc_types is not last.\n");
            service_ifc = 0;
         }
         break;
      }
   }

   if (strlen_ifc_types != (ctx->num_ifc_in + ctx->num_ifc_out + service_ifc)) {
      trap_errorf(ctx, TRAP_E_BADPARAMS, "Number of given ifc types is not equal to number of input and output ifc from module_info.");
      return ctx;
   }

   ctx->counter_send_message = (uint64_t *) calloc(ctx->num_ifc_out, sizeof(uint64_t));
   ctx->counter_recv_message = (uint64_t *) calloc(ctx->num_ifc_in, sizeof(uint64_t));
   ctx->counter_send_buffer = (uint64_t *) calloc(ctx->num_ifc_out, sizeof(uint64_t));
   ctx->counter_autoflush = (uint64_t *) calloc(ctx->num_ifc_out, sizeof(uint64_t));
   ctx->counter_recv_buffer = (uint64_t *) calloc(ctx->num_ifc_in, sizeof(uint64_t));

   // Create input interfaces
   if (ctx->num_ifc_in > 0) {
      ctx->in_ifc_list = (trap_input_ifc_t *) calloc(ctx->num_ifc_in, sizeof(trap_input_ifc_t));
      if (!ctx->in_ifc_list) {
         trap_error(ctx, TRAP_E_MEMORY);
         goto alloc_counter_failed;
      }
      /* set default value of datatimeout */
      for (i=0; i<ctx->num_ifc_in; ++i) {
         ctx->in_ifc_list[i].datatimeout = TRAP_WAIT;
      }
      if (ctx->num_ifc_in > 1) {
         ctx->in_ifc_results = (trap_multi_result_t *) calloc(1, IN_IFC_RESULTS_SIZE(ctx));
         if (ctx->in_ifc_results == NULL) {
            trap_errorf(ctx, TRAP_E_MEMORY, "Not enough memory for multi-result storage.");
            goto freein_list;
         }
         ctx->reader_threads = (struct reader_threads_s *) calloc(ctx->num_ifc_in, sizeof(struct reader_threads_s));
         if (ctx->reader_threads == NULL) {
            trap_errorf(ctx, TRAP_E_MEMORY, "Not enough memory for reader-threads.");
            goto freein_results;
         }
      }
      sem_init(&ctx->sem_collector, SEM_PSHARED, 0);
   }

   for (i = 0; i < ctx->num_ifc_in; i++) {
      if (pthread_mutex_init(&ctx->in_ifc_list[i].ifc_mtx, NULL) != 0) {
         goto freein_readers;
      }
      /* initialize reader-threads and their semaphores */
      if (ctx->num_ifc_in > 1) {
         struct reader_threads_arg *dataarg = (struct reader_threads_arg *) calloc(1, sizeof(struct reader_threads_arg));
         if (dataarg == NULL) {
            goto freein_readers;
         }
         dataarg->ctx = ctx;
         dataarg->thread_index = i;
         if (pthread_create(&ctx->reader_threads[i].thr, NULL, reader_threads_fn, (void *) dataarg) != 0) {
            VERBOSE(CL_ERROR, "Creation of reader thread failed.");
            trap_errorf(ctx, TRAP_E_MEMORY, "Creation of reader thread failed.");
            free(dataarg);
            goto freein_readers;
         }
         if (sem_init(&ctx->reader_threads[i].sem, SEM_PSHARED, 0) != 0) {
            VERBOSE(CL_ERROR, "Creation of reader semaphore failed.");
            trap_errorf(ctx, TRAP_E_MEMORY, "Creation of reader semaphore failed.");
            goto freein_readers;
         }
      }
      /* allocate extra bytes for TCPIP IFC checksum */
      ctx->in_ifc_list[i].buffer = (void *) calloc(1, TRAP_IFC_MESSAGEQ_SIZE + 1);
      if (ctx->in_ifc_list[i].buffer == NULL) {
         trap_errorf(ctx, TRAP_E_MEMORY, "Not enought memory for input ifc buffer.");
         goto freein_on_failed;
      }
      ctx->in_ifc_list[i].buffer_full = 0;
      ctx->in_ifc_list[i].buffer_pointer = ctx->in_ifc_list[i].buffer;

      /* call input IFC constructor */
      if (trapifc_in_construct(ctx, &ifc_spec, i) == EXIT_FAILURE) {
         goto freein_on_failed;
      }
   }

   // Create output interfaces
   if (ctx->num_ifc_out > 0) {
      ctx->out_ifc_list = (trap_output_ifc_t *) calloc(ctx->num_ifc_out, sizeof(trap_output_ifc_t));
      if (ctx->out_ifc_list == NULL) {
         trap_error(ctx, TRAP_E_MEMORY);
         goto freeall_on_failed;
      }
      /* set default value of datatimeout */
      for (i=0; i<ctx->num_ifc_out; ++i) {
         ctx->out_ifc_list[i].datatimeout = TRAP_WAIT;
      }
   }

   for (i = 0; i < ctx->num_ifc_out; i++) {
      ctx->out_ifc_list[i].buffer_header = (void *) calloc(1, TRAP_IFC_MESSAGEQ_SIZE + sizeof(trap_buffer_header_t) + 1);
      if (ctx->out_ifc_list[i].buffer_header == NULL) {
         trap_errorf(ctx, TRAP_E_MEMORY, "Not enought memory for input ifc buffer.");
         goto freein_on_failed;
      }
      ctx->out_ifc_list[i].buffer = ((trap_buffer_header_t *) ctx->out_ifc_list[i].buffer_header)->data;
      ctx->out_ifc_list[i].buffer_index = 0;
      ctx->out_ifc_list[i].bufferflush = 0;
      if (pthread_mutex_init(&ctx->out_ifc_list[i].ifc_mtx, NULL) != 0) {
         goto freein_on_failed;
      }
      ctx->out_ifc_list[i].timeout = TRAP_IFC_TIMEOUT;
      ctx->out_ifc_list[i].bufferswitch = 1;

      /* call output IFC constructor */
      if (trapifc_out_construct(ctx, &ifc_spec, i) == EXIT_FAILURE) {
         goto freeall_on_failed;
      }

   }

   if (ctx->num_ifc_out > 0) {
      ctx->ifc_autoflush_timeout = calloc(ctx->num_ifc_out, sizeof(struct out_ifc_timeout_s));
      // Create thread for handling timeouts outputs interfaces
      if (pthread_create(&ctx->timeout_thread, NULL, trap_automatic_flush_thr, (void *) ctx) != 0) {
         VERBOSE(CL_ERROR, "Creation of timeout handler thread failed.");
         trap_errorf(ctx, TRAP_E_MEMORY, "Creation of reader thread failed.");
         goto freeall_on_failed;
      }
      ctx->timeout_thread_initialized = 1;
   }

   if ((strlen_ifc_types > (ctx->num_ifc_out + ctx->num_ifc_in)) &&
         (ifc_spec.types[ctx->num_ifc_out + ctx->num_ifc_in] == TRAP_IFC_TYPE_SERVICE)) {
      create_service_thread(ctx, ifc_spec.params[ctx->num_ifc_out + ctx->num_ifc_in]);
   } else {
      VERBOSE(CL_VERBOSE_ADVANCED,"Service ifc will not be opened.");
   }

   if (pthread_rwlock_wrlock(&ctx->context_lock) != 0) {
      VERBOSE(CL_ERROR, "Locking of context failed. %s", __func__);
   }
   ctx->initialized = 1;
   ctx->terminated = 0;
   pthread_rwlock_unlock(&ctx->context_lock);
//success:
   return ctx;

//freeall_on_failed_thr:
   if (pthread_rwlock_wrlock(&ctx->context_lock) != 0) {
      VERBOSE(CL_ERROR, "Locking of context failed. %s", __func__);
   }
   ctx->terminated = 1;
   pthread_rwlock_unlock(&ctx->context_lock);
   pthread_join(ctx->timeout_thread, NULL);
   ctx->timeout_thread_initialized = 0;
freeall_on_failed:
   for (i=0; i<ctx->num_ifc_out; ++i) {
      pthread_mutex_destroy(&ctx->out_ifc_list[i].ifc_mtx);
      if (ctx->out_ifc_list[i].destroy != NULL) {
         if (ctx->out_ifc_list[i].priv != NULL) {
            ctx->out_ifc_list[i].destroy(ctx->out_ifc_list[i].priv);
         }
         if (ctx->out_ifc_list[i].buffer_header != NULL) {
            free(ctx->out_ifc_list[i].buffer_header);
            ctx->out_ifc_list[i].buffer_header = NULL;
         }
      }
   }
   free(ctx->out_ifc_list);
   ctx->out_ifc_list = NULL;
freein_on_failed:
   for (i=0; i<ctx->num_ifc_in; ++i) {
      pthread_mutex_destroy(&ctx->in_ifc_list[i].ifc_mtx);
      if (ctx->in_ifc_list[i].destroy != NULL) {
         if (ctx->in_ifc_list[i].priv != NULL) {
            ctx->in_ifc_list[i].destroy(ctx->in_ifc_list[i].priv);
         }
      }
      if (ctx->in_ifc_list[i].buffer != NULL) {
         free(ctx->in_ifc_list[i].buffer);
         ctx->in_ifc_list[i].buffer = NULL;
      }
   }
freein_readers:
   if (pthread_rwlock_wrlock(&ctx->context_lock) != 0) {
      VERBOSE(CL_ERROR, "Locking of context failed. %s", __func__);
   }
   ctx->terminated = 1;
   pthread_rwlock_unlock(&ctx->context_lock);

   if (ctx->reader_threads != NULL) {
      for (i = 0; i < ctx->num_ifc_in; i++) {
         pthread_kill(ctx->reader_threads[i].thr, 1);
         pthread_join(ctx->reader_threads[i].thr, NULL);
         sem_destroy(&ctx->reader_threads[i].sem);
      }
      free(ctx->reader_threads);
      ctx->reader_threads = NULL;
   }
freein_results:
   if (ctx->in_ifc_results) {
      free(ctx->in_ifc_results);
      ctx->in_ifc_results = NULL;
   }
freein_list:
   if (ctx->in_ifc_list) {
      free(ctx->in_ifc_list);
      ctx->in_ifc_list = NULL;
   }
alloc_counter_failed:
   if (ctx->counter_send_message) {
      free(ctx->counter_send_message);
      ctx->counter_send_message = NULL;
   }
   if (ctx->counter_recv_message) {
      free(ctx->counter_recv_message);
      ctx->counter_recv_message = NULL;
   }
   if (ctx->counter_send_buffer) {
      free(ctx->counter_send_buffer);
      ctx->counter_send_buffer = NULL;
   }
   if (ctx->counter_autoflush) {
      free(ctx->counter_autoflush);
      ctx->counter_autoflush = NULL;
   }
   return ctx;
}

int trap_ctx_ifcctl(trap_ctx_t *ctx, int8_t type, uint32_t ifcidx, int32_t request, ... /* arg */)
{
   va_list ap;
   int res;
   va_start(ap, request);
   res = trap_ctx_vifcctl(ctx, type, ifcidx, request, ap);
   va_end(ap);
   return res;
}

int trap_ctx_vifcctl(trap_ctx_t *ctx, int8_t type, uint32_t ifcidx, int32_t request, va_list ap)
{
   char en_dis_switch = 0;
   uint64_t timeout = 0;
   int32_t datatimeout;
   trap_ctx_priv_t *c = ctx;

   if ((ifcidx >= c->num_ifc_out) && (ifcidx >= c->num_ifc_in)) {
      /* error - wrong interface index, because it should be less than number of input or output interfaces */
      VERBOSE(CL_ERROR, "Index of non-existing interface.");
      return TRAP_E_BADPARAMS;
   }

   if (pthread_rwlock_wrlock(&c->context_lock) != 0) {
      VERBOSE(CL_ERROR, "Locking of context failed. %s", __func__);
      return TRAP_E_IO_ERROR;
   }
   if (c->terminated == 1) {
      pthread_rwlock_unlock(&c->context_lock);
      return TRAP_E_TERMINATED;
   }
   switch (request) {
   case TRAPCTL_AUTOFLUSH_TIMEOUT:
      timeout = va_arg(ap, uint64_t);
      VERBOSE(CL_VERBOSE_BASIC, "%s ifc %d: Setting autoflush timeout to %lu.",
              ifcdir2str(type), (int)ifcidx, timeout);
      if (type == TRAPIFC_OUTPUT) {
         pthread_mutex_lock(&c->out_ifc_list[ifcidx].ifc_mtx);
         c->out_ifc_list[ifcidx].timeout = timeout;
         c->ifc_change = 1;
         pthread_mutex_unlock(&c->out_ifc_list[ifcidx].ifc_mtx);
      }
      break;
   case TRAPCTL_BUFFERSWITCH:
      en_dis_switch = (char) va_arg(ap, int);
      VERBOSE(CL_VERBOSE_BASIC, "%s ifc %d: Set buffer enabled to %d.",
              ifcdir2str(type), (int)ifcidx, (int) en_dis_switch);
      if (type == TRAPIFC_OUTPUT) {
         pthread_mutex_lock(&c->out_ifc_list[ifcidx].ifc_mtx);
         c->out_ifc_list[ifcidx].bufferswitch = en_dis_switch;
         c->ifc_change = 1;
         pthread_mutex_unlock(&c->out_ifc_list[ifcidx].ifc_mtx);
      }
      break;
   case TRAPCTL_SETTIMEOUT:
      /*
       * datatimeout is used only by get_data() and send_data() in one thread,
       * it is probably not necessary to lock anything.
       */
      datatimeout = (int32_t) va_arg(ap, int32_t);
      VERBOSE(CL_VERBOSE_BASIC, "%s ifc %d: Setting timeout to %d.",
              ifcdir2str(type), (int)ifcidx, datatimeout);
      if (type == TRAPIFC_OUTPUT) {
         c->out_ifc_list[ifcidx].datatimeout = datatimeout;
      } else if (type == TRAPIFC_INPUT) {
         c->in_ifc_list[ifcidx].datatimeout = datatimeout;
      }
      break;

   default:
      VERBOSE(CL_ERROR, "Unknown type of request.");
   }
   pthread_rwlock_unlock(&c->context_lock);
   return TRAP_E_OK;
}

int trap_ctx_get_last_error(trap_ctx_t *ctx)
{
   trap_ctx_priv_t *c = ctx;
   return c->trap_last_error;
}

const char *trap_ctx_get_last_error_msg(trap_ctx_t *ctx)
{
   trap_ctx_priv_t *c = ctx;
   return c->trap_last_error_msg;
}

void trap_ctx_send_flush(trap_ctx_t *ctx, uint32_t ifc)
{
   trap_ctx_priv_t *c = ctx;
   if (!c || !c->initialized) {
      return;
   }
   trap_store_into_buffer(c, ifc, (void *) c, 0, c->out_ifc_list[ifc].datatimeout, 1);
}

/**
 * @}
 */

/**
 * \addtogroup supervisor Supervisor monitoring feature
 * @{
 */
/**
 * Structure that contains arguments passed to service thread.
 */
typedef struct trap_service_thread_arg_s {
   /**
    * pointer to libtrap context
    */
   trap_ctx_priv_t *ctx;
   /**
    * IFC params
    */
   char *params;
} trap_service_thread_arg_t;

int service_get_data(int supervisor_sd, void *data)
{
   int sizeof_recv = sizeof(int);
   int total_received = 0;
   int last_received = 0;

   while (total_received < sizeof_recv) {
      last_received = recv(supervisor_sd, data + total_received, sizeof_recv - total_received, MSG_DONTWAIT);
      if (last_received == 0) {
         VERBOSE(CL_VERBOSE_ADVANCED,"------- ! Supervisors service thread closed its socket, im done !");
         return 2;
      }
      if (last_received == -1) {
         if (errno == EAGAIN) {
            return 0;
         }
         VERBOSE(CL_VERBOSE_ADVANCED,"RECV returned -1... error");
         return 2;
      }
      total_received += last_received;
   }

   return 1;
}

/**
 * Service IFC thread function.
 *
 * This function is run in separate thread.  It waits for incoming
 * connections e.g. from supervisor.  Service IFC can send IFC counters
 * declared in #trap_ctx_priv_s
 * \param[in] arg   service thread arguments in #trap_service_thread_arg_t
 */
void *service_thread_routine(void *arg)
{
   int ret_val, y, supervisor_sd;
   trap_service_thread_arg_t *arguments = (trap_service_thread_arg_t *) arg;
   trap_output_ifc_t *service_ifc = (trap_output_ifc_t *) calloc(1, sizeof(trap_output_ifc_t));
   tcpip_sender_private_t *priv;
   int request[1];
   int i; /* loop var */
   struct client_s *cl;

   /* set of file descriptors for the main loop with select: */
   fd_set fds;
   int maxfd;

   trap_ctx_priv_t *g_ctx = arguments->ctx;


   /** \todo add missing counter */

   int num_ints_tosend = TRAP_IN_IFC_COUNTERS * g_ctx->num_ifc_in + TRAP_OUT_IFC_COUNTERS * g_ctx->num_ifc_out;
   uint64_t *data = (uint64_t *) calloc(num_ints_tosend, sizeof(uint64_t));

   /* service port does not create thread for accepting clients */
   if (create_tcpip_sender_ifc(NULL, arguments->params, service_ifc, TRAP_IFC_TCPIP_SERVICE) != TRAP_E_OK) {
      VERBOSE(CL_ERROR,"Error while creating service IFC.");
      goto exit_service_thread;
   }

   priv = (tcpip_sender_private_t *) service_ifc->priv;
   while (1) {
      if (pthread_rwlock_rdlock(&g_ctx->context_lock) != 0) {
         VERBOSE(CL_ERROR, "Locking of context failed. %s", __func__);
         break;
      }
      if (g_ctx->terminated != 0) {
         pthread_rwlock_unlock(&g_ctx->context_lock);
         break;
      }
      pthread_rwlock_unlock(&g_ctx->context_lock);
      /* prepare file descriptor set */
      maxfd = priv->server_sd + 1;
      FD_ZERO(&fds);
      FD_SET(priv->server_sd, &fds);
      for (i=0; i<priv->clients_arr_size; ++i) {
         cl = &priv->clients[i];
         if (cl->sd > 0) {
            FD_SET(cl->sd, &fds);
            if (maxfd <= cl->sd) {
               maxfd = cl->sd + 1;
            }
         }
      }
      ret_val = select(maxfd, &fds, NULL, NULL, NULL);
      if (ret_val == -1) {
         if (errno == EINTR) {
            /* received interrupt, go to next terminated condition */
            continue;
         }
         VERBOSE(CL_ERROR, "Select() failed in service thread.");
         break;
      } else if (ret_val == 0) {
         /* no data - strange in blocking mode... */
         continue;
      } else {
         /* handle all read events - requests / new client */
         for (i=0; i<priv->clients_arr_size; ++i) {
            cl = &priv->clients[i];
            if (cl->sd > -1 && FD_ISSET(cl->sd, &fds)) {
               supervisor_sd = cl->sd;
               if (!(ret_val = service_get_data(supervisor_sd, (void *) request))) {
                  continue;
               } else if (ret_val == 2) {
                  /* disconnected client */
                  close(cl->sd);
                  cl->sd = -1;
               } else {
                  VERBOSE(CL_VERBOSE_ADVANCED,"----- Got request from supervisor | modul <- supervisor");

                  switch (*request) {
                  case 0:
                     break;
                  case 1:
                     VERBOSE(CL_VERBOSE_ADVANCED,"counter_recv_message:  ");
                     for (y=0; y<g_ctx->num_ifc_in; ++y) {
                        VERBOSE(CL_VERBOSE_ADVANCED,"%"PRIu64"  ", g_ctx->counter_recv_message[y]);
                     }
                     VERBOSE(CL_VERBOSE_ADVANCED,"counter_send_message:  ");
                     for (y=0;y<g_ctx->num_ifc_out; ++y) {
                        VERBOSE(CL_VERBOSE_ADVANCED,"%"PRIu64"  ", g_ctx->counter_send_message[y]);
                     }
                     VERBOSE(CL_VERBOSE_ADVANCED,"counter_send_buffer:  ");
                     for (y=0; y<g_ctx->num_ifc_out; ++y) {
                        VERBOSE(CL_VERBOSE_ADVANCED,"%"PRIu64"  ", g_ctx->counter_send_buffer[y]);
                     }
                     VERBOSE(CL_VERBOSE_ADVANCED,"counter_autoflush:  ");
                     for (y=0; y<g_ctx->num_ifc_out; ++y) {
                        VERBOSE(CL_VERBOSE_ADVANCED,"%"PRIu64"  ", g_ctx->counter_autoflush[y]);
                     }

                     for (y=0; y<g_ctx->num_ifc_in; ++y) {
                        data[y] = g_ctx->counter_recv_message[y];
                     }
                     for (y=0; y<g_ctx->num_ifc_out; ++y) {
                        data[y + g_ctx->num_ifc_in] = g_ctx->counter_send_message[y];
                     }
                     for (y=0; y<g_ctx->num_ifc_out; ++y) {
                        data[y + g_ctx->num_ifc_in + g_ctx->num_ifc_out] = g_ctx->counter_send_buffer[y];
                     }
                     for (y=0; y<g_ctx->num_ifc_out; ++y) {
                        data[y + g_ctx->num_ifc_in + g_ctx->num_ifc_out + g_ctx->num_ifc_out] = g_ctx->counter_autoflush[y];
                     }

                     send(supervisor_sd, (void *) data, num_ints_tosend * sizeof(uint64_t), 0);
                     break;

                  default:
                     break;
                  }
                  VERBOSE(CL_VERBOSE_ADVANCED,"----- Sent answer to supervisor | modul->supervisor");
               }
            }
         }
         if (FD_ISSET(priv->server_sd, &fds)) {
            /* accept new client */
            for (i=0; i<priv->clients_arr_size; ++i) {
               cl = &priv->clients[i];
               if (cl->sd == -1) {
                  cl->sd = accept(priv->server_sd, NULL, NULL);
                  goto accept_success;
               }
            }
            /* not enough space, go away */
            close(accept(priv->server_sd, NULL, NULL));
accept_success:
            continue;
         }
      }
   }

   /* disconnect rest clients */
   for (i=0; i<priv->clients_arr_size; ++i) {
      cl = &priv->clients[i];
      if (cl->sd > 0) {
         close(cl->sd);
         cl->sd = 0;
      }
   }

exit_service_thread:
   free(arguments->params);
   free(arguments);
   free(data);
   service_ifc->terminate(service_ifc->priv);
   service_ifc->destroy(service_ifc->priv);
   free(service_ifc);
   pthread_exit(NULL);
}

void create_service_thread(trap_ctx_priv_t *ctx, const char *params)
{
   char *arg_params = strdup(params);
   if (arg_params == NULL) {
      ctx->service_thread_initialized = 0;
      return;
   }

   trap_service_thread_arg_t *arg = (trap_service_thread_arg_t *) calloc(1, sizeof(trap_service_thread_arg_t));
   arg->params = arg_params;
   arg->ctx = ctx;
   pthread_create(&ctx->service_thread, NULL, service_thread_routine, (void *) arg);
   ctx->service_thread_initialized = 1;
}

/**
 * \brief Create dump files.
 *
 * Create dump files for debug as follows:
 *  trap-i[number]-config.txt   Output interface configuration.
 *  trap-i[number]-buffer.dat    Output interface buffer
 *  trap-o[number]-config.txt  Input interface configuration.
 *  trap-o[number]-buffer.dat   Input interface buffer
 *
 * \param[in] ctx   Pointer to the private libtrap context data (#trap_ctx_init()).
 * \param[in] path  Output directory, if NULL use current working directory.
 */
void trap_ctx_create_ifc_dump(trap_ctx_t *ctx, const char *path)
{
   const char *td = "./";
   uint32_t i;

   if (path != NULL) {
      td = path;
   }

   trap_ctx_priv_t *c = ctx;
   if (!c || !c->initialized) {
      VERBOSE(CL_ERROR, "Not initialized libtrap context, skipping...");
      return;
   }
   for (i = 0; i < c->num_ifc_in; i++) {
      c->in_ifc_list[i].create_dump(c->in_ifc_list[i].priv, i, td);
   }
   for (i = 0; i < c->num_ifc_out; i++) {
      c->out_ifc_list[i].create_dump(c->out_ifc_list[i].priv, i, td);
   }
}

int trap_ctx_get_client_count(trap_ctx_t *ctx, uint32_t ifcidx)
{
   trap_ctx_priv_t *c = ctx;
   if (!c || !c->initialized || ifcidx > c->num_ifc_out) {
      return -1;
   }
   return c->out_ifc_list[ifcidx].get_client_count(c->out_ifc_list[ifcidx].priv);
}

/**
 * @}
 */

